# 前端工程化

## 1. 什么是工程化

### 1.1 什么是前端工程化

- 工程化是一种思想，将前端开发流程规范化、标准化，提高开发效率，降低维护成本

### 1.2 工程化的发展

- 早期：手动管理依赖、手动处理模块化、手动合并压缩代码、手动处理资源路径、手动处理浏览器兼容性
- 中期：借助工具（如grunt、gulp）自动处理依赖、模块化、合并压缩代码、处理资源路径、处理浏览器兼容性
- 现阶段：借助工具（如webpack、rollup）自动处理依赖、模块化、合并压缩代码、处理资源路径、处理浏览器兼容性、处理代码规范、处理单元测试、处理项目构建、处理项目部署

### 1.3 前端工程化的应用场景

- 单页面应用
- 微信小程序
- 企业级管理系统
- 组件库

## 2. 前端工程化的核心

### 2.1 模块化

- 模块化是一种将复杂系统分解为可管理、可维护、可复用的代码单元的思想
- 模块化的发展：全局函数、命名空间、AMD、CMD、CommonJS、ES6模块

### 2.2 组件化

- 组件化是一种将UI拆分为独立、可复用的组件，以提高开发效率、降低维护成本的思想
- 组件化的应用场景：单页面应用、微信小程序、企业级管理系统、组件库
- 组件化的实现方式：Vue、React、Angular

### 2.3 规范化

- 规范化是一种将开发流程、代码风格、项目结构等规范化，以提高开发效率、降低维护成本的思想
- 规范化的应用场景：代码规范、项目结构、构建流程、部署流程、单元测试、代码审查

## 3. 前端工程化的工具

### 3.1 模块化工具

- Webpack：一个强大的模块打包工具，支持各种模块化规范，可以进行代码打包、压缩、优化等操作
- Rollup： 一个轻量级的模块打包工具，适用于库和框架的开发，支持ES6模块化规范，可以进行代码打包、压缩、优化等操作
- Parcel： 一个零配置的模块打包工具，支持多种文件类型，可以进行代码打包、压缩、优化等操作

### 3.2 组件化工具

- Vue CLI：一个基于Vue.js的脚手架工具，可以快速创建Vue项目，支持组件化开发、热更新、代码打包等操作
- Create React App：一个基于React.js的脚手架工具，可以快速创建React项目，支持组件化开发、热更新、代码打包等操作
- Angular CLI： 一个基于Angular.js的脚手架工具，可以快速创建Angular项目，支持组件化开发、热更新、代码打包等操作

### 3.3 规范化工具

- ESLint
- Prettier
- Stylelint
- Husky
- Lint-staged

### 3.4 构建工具

- Gulp： 一个基于流的自动化构建工具，可以自动化处理任务，如代码压缩、合并、编译等操作
- Grunt： 一个基于任务的自动化构建工具，可以自动化处理任务，如代码压缩、合并、编译等操作

### 3.5 部署工具

- Jenkins
- GitLab CI/CD
- GitHub Actions

## 4. 前端工程化的实践

### 4.1 模块化实践

- 使用Webpack进行模块化打包
- 使用ES6模块化语法
- 使用Babel进行代码转换

### 4.2 组件化实践

- 使用Vue CLI创建Vue项目
- 使用Create React App创建React项目
- 使用Angular CLI创建Angular项目

### 4.3 规范化实践

- 使用ESLint进行代码规范检查
- 使用Prettier进行代码格式化

### 4.4 构建实践

- 使用Gulp进行自动化构建
- 使用Grunt进行自动化构建

### 4.5 部署实践

- 使用Jenkins进行持续集成和持续部署
- 使用GitLab CI/CD进行持续集成和持续部署
- 使用GitHub Actions进行持续集成和持续部署

## 5. 脚手架的能力

- 创建项目：根据模板创建项目
- 代码规范：自动检查代码规范，并给出提示
- 代码格式化：自动格式化代码，使其符合规范
- 代码打包：自动打包代码，生成可部署的文件
- 代码压缩：自动压缩代码，减小文件大小
- 代码优化：自动优化代码，提高代码执行效率
- 代码部署：自动部署代码到服务器
- 代码测试：自动测试代码，确保代码质量
- 代码审查：自动审查代码，确保代码质量
- 代码监控：自动监控代码，确保代码质量
- 代码回滚：自动回滚代码，确保代码质量
- 代码发布：自动发布代码，确保代码质量
- 代码更新：自动更新代码，确保代码质量
- 代码备份：自动备份代码，确保代码质量

常用脚手架有哪些？

- Webpack CLI
- Vue CLI
- Create React App
- Angular CLI
- ...

## 6. 稳定性建设

项目中经常遇到的稳定性问题：

- 线上bug
- 代码异常
- 代码报错
- 代码崩溃
- 代码性能问题

### 6.1 可预防

- 规范文档建设
- 开发脚手架建设（git hooks、git commit配置、eslint、prettier、stylelint、husky、lint-staged）
- 通用组件、物料库建设
- 攻防演练（线上代码注入、线上代码篡改、线上代码劫持）
- 灰度发布

### 6.2 可监控

🥨 **TODO:** 前端监控系统

- 监控告警（监控线上代码异常、监控线上代码报错、监控线上代码崩溃、监控线上代码性能问题）
- 日志收集（收集线上代码日志，便于排查问题）
- 日志分析（分析线上代码日志，便于排查问题）
- 日志可视化（将线上代码日志可视化，便于排查问题）
- 日志报警（将线上代码日志报警，便于排查问题）

### 6.3 可回滚

- 容器化部署（将代码部署到容器中，便于回滚）
- 数据迁移（将数据迁移到新的服务器中，便于回滚）

## 7. npm包管理

npm属于前端工程化的一部分，用于管理JavaScript包和依赖关系。

### 7.1 npm包管理器

- npm是一个基于Node.js的包管理器，用于管理JavaScript包和依赖关系
- npm包管理器可以安装、卸载、更新、发布、搜索、分享JavaScript包

### 7.2 package.json

- package.json是一个JavaScript包的配置文件，用于描述包的元数据、依赖关系、脚本等
- package.json文件通常位于项目的根目录下
- package.json文件可以使用npm init命令生成

```txt
package.json文件内部各个属性的说明：
{
  "name": "my-package", // 包的名称
  "version": "1.0.0", // 包的版本号
  "description": "A simple package", // 包的描述
  "main": "index.js", // 包的入口文件
  "bin": "bin/my-package", // 包的可执行文件
  "files": ["index.js", "bin"], // 包的文件列表,用于指定哪些文件应该被包含在包中
  "scripts": { // 包的脚本
    "start": "node index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [ // 包的关键词,用于搜索包
    "simple",
    "package"
  ],
  "author": "John Doe", // 包的作者
  "license": "MIT", // 包的许可证,用于指定包的许可证类型(MIT、Apache、GPL等)
  "dependencies": { // 包的依赖关系
    "express": "^4.17.1"
  },
  "devDependencies": { // 包的开发依赖关系
    "mocha": "^8.3.2"
  },
  "publishConfig": { // 包的发布配置
    "registry": "https://registry.npmjs.org/
  }
}
```

### 7.3 包版本管理机制

- npm包版本号遵循语义化版本规范，格式为`主版本号.次版本号.修订号`
- 主版本号：当包的API发生重大变化，不兼容旧版本时，主版本号递增
- 次版本号：当包新增功能，但向后兼容时，次版本号递增
- 修订号：当包修复bug，但向后兼容时，修订号递增
- npm包版本号可以使用`^`、`~`、`>`、`<`、`=`、`||`等符号进行版本约束
- npm包版本号可以使用`npm install`命令进行安装，可以使用`npm uninstall`命令进行卸载，可以使用`npm update`命令进行更新
- npm包版本号可以使用`npm publish`命令进行发布，可以使用`npm unpublish`命令进行撤销发布
- npm包版本号可以使用`npm view`命令查看包的版本信息，可以使用`npm info`命令查看包的详细信息

### 7.4 npm install原理

- 嵌套结构，该结构是树状的，每个节点代表一个包，每个节点有多个子节点，每个子节点代表一个依赖包。
- 扁平结构，该结构是线性的，每个节点代表一个包，每个节点只有一个子节点，该子节点代表该包的依赖包。
- lock文件，该文件用于记录包的版本信息，以便在下次安装时能够快速找到对应的包版本。
- 缓存，该缓存用于存储已经下载过的包，以便在下次安装时能够快速找到对应的包。

npm install整体执行流程：

```txt
1.检查 .npmrc 文件。优先级：项目级别 > 用户级别 > 全局级别 > npm 内置级别
2.检查 package-lock.json 文件，如果存在，则使用该文件中的版本信息进行安装，否则执行下一步
3. 无package-lock.json 文件，则根据 package.json 文件中的版本信息进行安装
3.1 解析依赖树，生成依赖树
3.2 下载依赖包，并生成缓存
3.3 将依赖包安装到 node_modules 目录中
3.4 生成 package-lock.json 文件
```

## 8. 前端包管理工具

有哪些前端包管理工具？

- npm
- yarn
- pnpm

上述包管理工具的优缺点表格如下：

| 包管理工具 | 优点 | 缺点 |
| --- | --- | --- |
| npm | 1. 生态系统最成熟，使用最广泛<br>2. 支持语义化版本控制<br>3. 支持私有仓库 | 1. 安装速度较慢<br>2. 安装过程中可能会出现错误<br>3. 缓存机制不够完善 |
| yarn | 1. 安装速度快<br>2. 安装过程中不会出现错误<br>3. 缓存机制完善 | 1. 生态系统相对较新，使用范围有限<br>2. 不支持私有仓库 |
| pnpm | 1. 安装速度快<br>2. 安装过程中不会出现错误<br>3. 缓存机制完善<br>4. 节省磁盘空间 | 1. 生态系统相对较新，使用范围有限<br>2. 不支持私有仓库 |

推荐使用pnpm，因为pnpm可以节省磁盘空间，并且可以加快安装速度。

## 9. 前端项目管理

Monorepo的演进

- 阶段一：Monolith，所有代码放在一个仓库中
- 阶段二：MultiRepo，将代码拆分成多个仓库，每个仓库负责一个功能模块，但是每个仓库都有自己的依赖关系
- 阶段三：Monorepo，将代码放在一个仓库中，但是每个功能模块都有自己的依赖关系，并且这些依赖关系是相互独立的

### 9.1 参考

[了解更全面的 Monorepo](https://juejin.cn/post/7215886869199896637)

### 9.2 轻量化 Monorepo 方案

- lerna，是一个用于管理JavaScript项目的工具，它可以帮助你将多个包组织在一个仓库中，并且可以自动处理依赖关系和版本管理。
- nx
- rush

### 9.3 重度定制 Monorepo 方案

- bit
- turborepo
