# 设计模式之创建式

## 2. 创建式模式

:::tip
创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性，将创建和使用代码解耦。
:::

### 2.1 单例模式

单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问它的全局访问点。在前端开发中，可以使用单例模式来管理全局状态和资源。

现代单例模式实现：

```js
// MySingleton.js
// 在模块内部创建实例
class MySingleton {
  constructor() {
    if (MySingleton.instance) {
      return MySingleton.instance;
    }
    console.log("Singleton instance created.");
    // ... 初始化代码 ...
    MySingleton.instance = this;
  }

  // ... public methods ...
  doSomething() {
    console.log("Doing something...");
  }
}

// 导出这个唯一的实例
const instance = new MySingleton();
export default instance;
```

使用：

```js
import mySingletonInstance from "./MySingleton.js";

mySingletonInstance.doSomething(); // 输出: Singleton instance created. Doing something...
```

#### Q: ESM 中 export import 的实现是设计模式中的单例模式吗？

A: 不是，ESM 中的 export import 的实现是模块化设计模式中的模块模式。模块模式是一种设计模式，用于将代码组织成可重用的模块，每个模块都有自己的私有变量和函数，并且可以通过公开的接口与外部通信。模块模式可以用于创建单例对象，但是它并不是单例模式本身。模块的“单例”行为是其实现机制带来的一个自然结果，而不是它的首要设计目标。

### 2.2 建造者模式

建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。在前端开发中，可以使用建造者模式来构建复杂的对象，例如表单、对话框等。

:::tip
工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。
:::

建造者模式实现：表单实践

```js
class Form {
  constructor() {
    this.fields = [];
  }

  addField(field) {
    this.fields.push(field);
  }

  render() {
    const formElement = document.createElement("form");
    this.fields.forEach((field) => {
      formElement.appendChild(field.render());
    });
    return formElement;
  }
}

class Field {
  constructor(label, type, value) {
    this.label = label;
    this.type = type;
    this.value = value;
  }

  render() {
    const fieldElement = document.createElement("div");
    const labelElement = document.createElement("label");
    labelElement.textContent = this.label;
    const inputElement = document.createElement("input");
    inputElement.type = this.type;
    inputElement.value = this.value;
    fieldElement.appendChild(labelElement);
    fieldElement.appendChild(inputElement);
    return fieldElement;
  }
}

const form = new Form();
form.addField(new Field("Name", "text", "John"));
form.addField(new Field("Email", "email", "john@example.com"));

const formElement = form.render();
document.body.appendChild(formElement);
```

### 2.3 工厂模式

:::tip
工厂模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
:::

工厂模式：是定义一个创建对象的接口，让子类决定实例化哪一个类。在前端开发中，可以使用工厂模式来创建不同类型的组件，例如按钮、输入框等。

工厂模式实现：按钮实践

```js
class Button {
  constructor(text) {
    this.text = text;
  }

  render() {
    const buttonElement = document.createElement("button");
    buttonElement.textContent = this.text;
    return buttonElement;
  }
}

class Link {
  constructor(url, text) {
    this.url = url;
    this.text = text;
  }

  render() {
    const linkElement = document.createElement("a");
    linkElement.href = this.url;
    linkElement.textContent = this.text;
    return linkElement;
  }
}

class UIComponentFactory {
  static createComponent(type, options) {
    switch (type) {
      case "button":
        return new Button(options.text);
      case "link":
        return new Link(options.url, options.text);
      default:
        throw new Error(`Unknown component type: ${type}`);
    }
  }
}

const button = UIComponentFactory.createComponent("button", {
  text: "Click me",
});
const link = UIComponentFactory.createComponent("link", {
  url: "https://example.com",
  text: "Example",
});
document.body.appendChild(button.render());
document.body.appendChild(link.render());
```

### 2.4 原型模式

原型模式：是使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。在前端开发中，可以使用原型模式来创建对象，例如克隆组件、克隆数据等。

原型模式实现：克隆数据实践

```js
const data = {
  name: "John",
  age: 30,
  address: {
    city: "New York",
    country: "USA",
  },
};

const clonedData = Object.assign({}, data);
clonedData.address = Object.assign({
  ...clonedData.address,
});
```

原型模式实现：克隆组件实践

```js
class Component {
  constructor(props) {
    this.props = props;
  }

  render() {
    // 渲染组件的逻辑
  }
}

class Button extends Component {
  constructor(props) {
    super(props);
  }

  render() {
    // 渲染按钮的逻辑
  }
}

const button = new Button({ text: "Click me" });
const clonedButton = Object.assign({}, button);
clonedButton.props = Object.assign({}, button.props);
```

### 2.5 抽象工厂模式

抽象工厂模式：是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

:::tip
抽象工厂模式（Abstract Factory Pattern）的应用场景主要集中在需要创建一组相关或相互依赖的对象，并且不需要指定具体类的情况下。它常用于组件库、主题切换、跨平台适配等场景。
:::

#### 2.5.1 场景一（组件库的皮肤/主题切换）

组件库的皮肤/主题切换：例如，一个组件库需要支持多种皮肤或主题，可以使用抽象工厂模式来创建不同皮肤或主题的组件。

##### 说明

你有一套 UI 组件（如 Button、Input、Dialog），需要支持多套主题（如 light/dark、品牌 A/品牌 B），但不希望在业务代码中直接判断用哪个主题的组件。

##### 实现思路

定义一组抽象组件接口（如 IButton、IInput）。
每种主题实现一套具体组件（如 LightButton、DarkButton）。
用工厂类统一创建一组主题组件。

##### 示例

```js
// 抽象工厂
class ThemeFactory {
  createButton() {}
  createInput() {}
}

// 具体工厂
class LightThemeFactory extends ThemeFactory {
  createButton() {
    return new LightButton();
  }
  createInput() {
    return new LightInput();
  }
}
class DarkThemeFactory extends ThemeFactory {
  createButton() {
    return new DarkButton();
  }
  createInput() {
    return new DarkInput();
  }
}

// 使用
const factory = isDark ? new DarkThemeFactory() : new LightThemeFactory();
const btn = factory.createButton();
const input = factory.createInput();
```

#### 2.5.2 场景二（跨平台适配）

```txt
场景说明：
你要开发一套 UI，同时适配 Web、微信小程序、React Native 等不同平台，每个平台的组件实现方式不同，但业务层不想关心具体平台。
实现思路：
定义一组抽象组件接口。
每个平台实现一套具体组件。
用工厂类统一创建一组平台组件。
```

#### 2.5.3 场景三（表单控件的动态渲染）

```txt
场景说明：
你有一个表单生成器，根据不同的表单类型（如普通表单、搜索表单、弹窗表单）渲染不同风格的控件，但表单项类型是动态的。
实现思路：
定义抽象控件工厂。
不同表单类型实现不同的控件工厂。
通过工厂创建一组表单控件。
```

#### 2.5.4 场景四（国际化/多语言组件）

```txt
场景说明：
根据不同的语言环境，渲染不同的组件或内容（如中英文 Button、Dialog）。
实现思路：
定义抽象组件工厂。
每种语言实现一套具体组件。
用工厂统一创建。
```

#### 2.5.5 场景五（复杂业务场景下的“产品族”切换）

```txt
比如：
不同业务线（如电商/教育/医疗）有一套自己的 UI 组件和业务逻辑，但接口一致。
通过抽象工厂统一切换“产品族”。
```

#### 总结

抽象工厂模式在前端的典型应用场景：

- 主题/皮肤切换
- 跨平台组件适配
- 动态表单控件渲染
- 国际化组件
- 多业务线产品族切换

优点：

- 解耦业务与具体实现
- 易于扩展和维护
- 统一产品族的创建

### 2.6 生成器模式

生成器模式是一种创建型设计模式，允许使用相同的创建代码生成不同类型和形式的对象。

:::tip
前端开发中，生成器模式（建造者模式，Builder Pattern）的应用场景主要集中在需要分步骤构建一个复杂对象，并且构建过程可以灵活变化的场合。它可以让你用链式调用、分阶段配置等方式，优雅地创建复杂对象或结构。
:::

#### 2.6.1 场景一（表单/页面/组件的动态生成）

##### 1.场景说明

你需要根据配置动态生成表单、页面或复杂组件。表单项、校验规则、布局等都可以灵活配置。

##### 2.实现思路

定义一个抽象生成器接口。
每种表单类型实现具体生成器。
通过生成器统一创建表单。

##### 3.示例

```js
class FormBuilder {
  constructor() {
    this.form = { fields: [] };
  }
  addInput(name, label) {
    this.form.fields.push({ type: "input", name, label });
    return this;
  }
  addSelect(name, label, options) {
    this.form.fields.push({ type: "select", name, label, options });
    return this;
  }
  setLayout(layout) {
    this.form.layout = layout;
    return this;
  }
  build() {
    return this.form;
  }
}

// 使用
const form = new FormBuilder()
  .addInput("username", "用户名")
  .addInput("password", "密码")
  .addSelect("gender", "性别", ["男", "女"])
  .setLayout("horizontal")
  .build();
```

#### 2.6.2 场景二（配置对象的链式构建）

**场景说明**

如 axios、echarts、ant-design-vue 的 message、modal 等，很多库都支持链式配置参数，底层其实就是生成器模式。

**示例**

```js
const chart = new ChartBuilder()
  .setTitle("销量")
  .setXAxis(["1月", "2月"])
  .setSeries([100, 200])
  .build();
```

#### 2.6.3 场景三（富文本/虚拟 DOM/AST 的构建）

**场景说明：**
如 React.createElement、Vue 的 h 函数、AST 语法树的构建等，底层都可以用生成器模式来组织。

**示例：**

```js
const vnode = new VNodeBuilder()
  .setTag("div")
  .addClass("container")
  .addChild(new VNodeBuilder().setTag("span").setText("Hello").build())
  .build();
```

```js
// Vue 的 h 函数
const vnode = h("div", { class: "container" }, [h("span", "Hello")]);
```

```js
// AST 语法树的构建
const ast = new ASTBuilder()
  .setProgram(
    new ASTBuilder().setBody([
      new ASTBuilder().setExpressionStatement(
        new ASTBuilder().setExpression(
          new ASTBuilder().setMemberExpression(
            new ASTBuilder().setIdentifier("console"),
            new ASTBuilder().setIdentifier("log")
          ),
          new ASTBuilder().setLiteral("Hello World")
        )
      ),
    ])
  )
  .build();
```

#### 2.6.4 场景三（动态生成 CSS/样式对象）

**场景说明：**
如 styled-components、emotion 等 CSS-in-JS 库，底层也常用生成器模式来组织样式生成。

```js
// styled-components 的使用
const Button = styled.button`
  background: ${(props) => (props.primary ? "blue" : "gray")};
  color: white;
  padding: 10px;
`;
```
