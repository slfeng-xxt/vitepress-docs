# 设计模式之结构型

## 3. 结构型模式

:::tip
结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

降低耦合，提升复用、便于扩展和维护、让新旧系统/多端/多库无缝协作

:::

### 3.1 适配器模式

前端开发中，适配器模式（Adapter Pattern）的应用场景非常广泛，主要用于“接口转换”，即当你需要让一个已有对象/库/组件的接口与当前系统期望的接口兼容时，就可以用适配器模式。它的核心作用是“兼容老接口/第三方接口/不同风格接口”，让它们能无缝协作。

#### 3.1.1 场景一（第三方库/老系统接口适配）

**场景说明：**
你引入了一个第三方库或老系统的 API，但它的接口风格和你项目的接口不一致。

**解决方法：**
写一个适配器，把第三方接口“包一层”，转换成你项目需要的格式。

**示例：**

```js
// 第三方返回 { user_name: 'Tom', user_age: 18 }
function thirdPartyApi() {
  return { user_name: "Tom", user_age: 18 };
}

// 适配器
function userAdapter(raw) {
  return {
    name: raw.user_name,
    age: raw.user_age,
  };
}

// 使用
const user = userAdapter(thirdPartyApi()); // { name: 'Tom', age: 18 }
```

#### 3.1.2 场景二（统一多平台/多端 API）

**场景说明：**
你要让同一套业务代码适配 Web、微信小程序、React Native 等不同平台，但各平台 API 不一致。

**解决方法：**
为每个平台写一个适配器，暴露统一接口，业务层只用统一接口。

**示例：**

```js
// web-adapter.js
export function showToast(msg) { alert(msg); }

// wx-adapter.js
export function showToast(msg) { wx.showToast({ title: msg }); }

// platform-adapter.js
import { showToast as showToastWx } from './wx-adapter';
import { showToast as showToastWeb } from './web-adapter';

export function showToast(msg) {
  if (isWx) {
    showToastWx(msg);
  } else {
    showToastWeb(msg);
  }
}

// 业务代码
import { showToast } from './platform-adapter';
showToast('Hello');
```

#### 3.1.3 场景三（组件库二次封装）

**场景说明：**
你要基于 Element UI、Ant Design 等组件库，封装一套业务组件库，但业务组件库要求 API 和现有组件库不一致。

**解决方法：**
为每个组件库的组件写一个适配器，暴露统一接口，业务层只用统一接口。

**示例：**

```js
// element-adapter.js
import { Button as ElementButton } from 'element-ui';

export function Button(props) {
  return <ElementButton {...props} />;
}

// antd-adapter.js
import { Button as AntdButton } from 'antd';

export function Button(props) {
  return <AntdButton {...props} />;
}

// platform-adapter.js
import { Button as ButtonElement } from './element-adapter';
import { Button as ButtonAntd } from './antd-adapter';

export function Button(props) {
  if (isAntd) {
    return <ButtonAntd {...props} />;
  } else {
    return <ButtonElement {...props} />;
  }
}

// 业务代码
import { Button } from './platform-adapter';
<Button type="primary">Hello</Button>;
```

#### 3.1.4 场景四（数据格式转换）

场景说明：
后端返回的数据结构和前端展示的数据结构不一致。

解决方法：
写一个适配器函数，把后端数据转换成前端需要的格式。

示例：

```js
// adapter.js
export function adaptTableData(rawList) {
  return rawList.map(item => ({
    key: item.id,
    label: item.name,
    value: item.value
  }));
}

// 业务代码
import { adaptTableData } from './adapter';

const rawList = [
  { id: 1, name: 'A', value: 100 },
  { id: 2, name: 'B', value: 200 }
];

const adaptedList = adaptTableData(rawList);
```

#### 3.1.5 其他场景

- 统一事件/手势/输入适配

```txt
场景说明：
不同浏览器/设备的事件（如鼠标、触摸、手势）API 不一致。
解决方法：
写一个适配器，统一事件处理接口。
```

- 旧代码迁移/重构

```txt
场景说明：
你在重构老项目，想用新接口，但又不能马上全部替换。
解决方法：
写适配器，让新旧代码能共存，逐步迁移。
```

### 3.2 桥接模式

:::tip
桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立变化。这种模式通过在抽象类中引入对实现类的引用，从而实现抽象类与实现类的解耦。

优点：
抽象与实现分离，便于独立扩展
支持多维度变化，避免类爆炸
降低耦合，提升灵活性
:::

前端开发中，桥接模式（Bridge Pattern）的应用场景主要是将抽象与实现解耦，使它们可以独立变化。桥接模式常用于多维度变化、平台适配、主题切换、渲染层分离等场景。

#### 3.2.1 主题与组件的解耦（主题切换）

- 场景说明：
你有一套 UI 组件（如 Button、Input），需要支持多套主题（如 light/dark），但不希望组件和主题实现强耦合。

- 桥接模式实现：
抽象部分：组件接口（如 Button）
实现部分：主题实现（如 LightTheme、DarkTheme）
组件通过桥接接口调用主题实现

- 示例：

```js
// 主题实现
class LightTheme { getColor() { return '#fff'; } }
class DarkTheme { getColor() { return '#000'; } }

// 抽象组件
class Button {
  constructor(theme) { this.theme = theme; }
  render() {
    return `<button style="background:${this.theme.getColor()}">按钮</button>`;
  }
}

// 使用
const btn = new Button(new DarkTheme());
btn.render();
```

#### 3.2.2 跨平台渲染（Web/Native/小程序）

```txt
场景说明：
你要开发一套业务逻辑，既能在 Web 上渲染，也能在小程序、Native 上渲染。
桥接模式实现：
抽象部分：业务逻辑
实现部分：不同平台的渲染实现
业务逻辑通过桥接接口调用不同平台的渲染
```

#### 3.2.3 图表/可视化渲染引擎解耦

```txt
场景说明：
你有一套图表 API，底层可能用 Canvas、SVG、WebGL 等不同渲染方式。
桥接模式实现：
抽象部分：图表 API
实现部分：不同渲染引擎
图表 API 通过桥接接口调用不同渲染引擎
```

#### 3.2.4 多维度产品族扩展

```txt
场景说明：
比如你有多种类型的消息（如 Email、短信、推送），每种消息又有多种发送渠道（如阿里云、腾讯云）。
桥接模式实现：
抽象部分：消息类型
实现部分：发送渠道
消息类型通过桥接接口调用不同渠道
```

### 3.3 组合模式

:::tip
组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

前端开发中，组合模式（Composite Pattern）的应用场景非常广泛，主要用于将对象组合成树形结构以表示“部分-整体”的层次结构，并且让客户端可以统一地处理单个对象和对象集合。它非常适合处理递归结构、树形结构、嵌套结构等场景。

优点：
统一处理单个对象和对象集合
便于递归操作和渲染
结构灵活，易于扩展
:::

#### 3.3.1 前端组件树/虚拟DOM

- 场景说明：
React、Vue 等框架的组件树、虚拟DOM（VNode）本质上就是组合模式的应用。
叶子节点：普通组件、文本节点
组合节点：容器组件、父组件

- 示例：

```js
class Component {
  render() {}
}
class Leaf extends Component {
  render() { /* 渲染叶子节点 */ }
}
class Composite extends Component {
  constructor() { this.children = []; }
  add(child) { this.children.push(child); }
  render() {
    this.children.forEach(child => child.render());
  }
}
```

#### 3.3.2 菜单/树形控件/文件目录

- 场景说明：
如左侧菜单、文件目录、组织架构树等，都是树形结构，节点可以是文件（叶子）或文件夹（组合）。

- 示例：

```js
const menu = [
  { name: '首页' },
  { name: '文档', 
    children: [
      { name: 'API' },
      { name: '指南' }
    ]
  }
];
```

#### 3.3.3 表单/表单项嵌套

- 场景说明：
如 Ant Design 表单组件，表单项可以嵌套，如 Form.Item、Form.List 等。

#### 3.3.4 富文本/AST/JSON Schema

- 场景说明：
富文本编辑器的内容、AST 语法树、JSON Schema 等，都是递归嵌套结构，适合用组合模式遍历和操作。

#### 3.3.5 图形编辑器/画布对象

- 场景说明：
如画布上的图形对象，可以是单个图形（叶子），也可以是组合图形（组合节点），统一支持移动、缩放等操作。

#### 3.3.6 权限系统/组织架构

- 场景说明：
权限、组织架构等本质上是树形结构，适合用组合模式统一增删查改。

### 3.4 装饰模式

:::tip
装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

前端开发中，装饰器模式（Decorator Pattern）的应用场景非常丰富，主要用于在不改变原有对象结构的情况下，动态地为对象添加功能。它可以让你灵活地为对象“包装”新能力，而无需修改原始代码。

优点：
不修改原有对象结构即可动态扩展功能
支持功能叠加、灵活组合
代码解耦、易于维护
:::

#### 3.4.1 组件增强（高阶组件 HOC）

- 场景说明：
在 React/Vue 等框架中，常用高阶组件（HOC）或“包装组件”来为原组件添加功能，比如权限校验、日志埋点、样式增强等。

- 示例：

```js
// React HOC 示例
function withLogger(WrappedComponent) {
  return function(props) {
    console.log('组件渲染', props);
    return <WrappedComponent {...props} />;
  }
}
const EnhancedComponent = withLogger(MyComponent);
```

#### 3.4.2 Vue 3 的自定义指令

- 场景说明：
通过自定义指令为 DOM 元素动态添加功能，比如 v-focus、v-copy、v-permission 等，本质上也是装饰器模式

#### 3.4.3 JavaScript ES7+ 装饰器语法

- 场景说明：
在类和方法上用 @decorator 语法动态增强功能，比如日志、缓存、权限、自动绑定等。

- 示例：

```js
function log(target, name, descriptor) {
  const oldValue = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`调用${name}，参数:`, args);
    return oldValue.apply(this, args);
  }
  return descriptor;
}

class Demo {
  @log
  say(msg) { console.log(msg); }
}
```

#### 3.4.4 事件处理增强

- 场景说明：
通过装饰器为事件处理函数动态添加功能，比如防抖、节流、错误处理等。

- 示例：

```js
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  }
}
const onInput = debounce(function(e) { /* ... */ }, 300);
```

#### 3.4.5 其他

- 请求/响应拦截器

```txt
场景说明：
如 axios 的请求/响应拦截器，可以为请求动态添加 token、日志、错误处理等功能。
```

- 样式/动画增强

```txt
场景说明：
为组件或 DOM 元素动态添加样式、动画、过渡等效果。
```

- 业务功能动态扩展

```txt
场景说明：
如表单校验、权限校验、埋点统计等，可以通过装饰器模式为原有功能动态扩展。
```

### 3.5 外观模式

:::tip
外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。

前端开发中，外观模式（Facade Pattern）的应用场景非常常见。外观模式的核心作用是为复杂子系统提供一个统一的简化接口，让调用者无需关心内部细节，只需通过“外观”对象即可完成复杂操作。
:::

#### 3.5.1 封装复杂的 API/SDK 调用

- 场景说明：
第三方 SDK（如地图、支付、富文本、播放器等）通常有很多初始化、配置、事件绑定等繁琐步骤。
外观模式做法：
封装成一个简单的接口，业务方只需一行代码即可完成复杂操作。

- 示例：

```js
// 外观
class MapFacade {
  constructor(containerId) {
    this.map = new MapSDK(containerId);
    this.map.init();
    this.map.setDefaultStyle();
    // ...各种初始化
  }
  setCenter(lat, lng) {
    this.map.setCenter({ lat, lng });
  }
  addMarker(lat, lng) {
    this.map.addMarker({ lat, lng });
  }
}
// 使用
const map = new MapFacade('map-container');
map.setCenter(39.9, 116.4);
map.addMarker(39.9, 116.4);
```

#### 3.5.2 统一管理浏览器兼容性问题

- 场景说明：
不同浏览器的 API 差异大，直接操作容易出错。
外观模式做法：
封装一组统一的接口，内部自动适配不同浏览器。

- 示例：

```js
const EventUtil = {
  addEvent(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler);
    } else {
      element.attachEvent('on' + type, handler);
    }
  },
  // ...更多兼容性方法
};
// 使用
EventUtil.addEvent(element, 'click', handler);
```

#### 3.5.3 统一封装本地存储/统一封装网络请求

- 场景说明：
localStorage、sessionStorage、cookie 操作繁琐且 API 不统一。
外观模式做法：
封装成 StorageFacade，提供统一的 get/set/remove 接口。

- 示例：

```js
const StorageFacade = {
  set(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  },
  get(key) {
    return JSON.parse(localStorage.getItem(key));
  },
  remove(key) {
    localStorage.removeItem(key);
  }
};
```

### 3.6 享元模式

:::tip
享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。

前端开发中，享元模式（Flyweight Pattern）的应用场景主要集中在需要大量创建相似对象、对象数量巨大、内存优化的场合。享元模式的核心思想是共享内部状态，减少对象数量，节省内存。
:::

#### 3.6.1 虚拟列表/大数据量渲染

- 场景说明：
如长列表、表格、无限滚动等场景，页面上可能有成千上万个数据项，但实际只渲染可视区域的少量 DOM 节点，复用这些节点来显示不同数据。
- 实现思路：
只创建和维护可视区域需要的 DOM 元素（如 20 个），滚动时复用这些元素，改变其内容和位置。
这就是享元模式的典型应用：节点对象被复用，数据是外部状态。
- 相关库：
react-window、vue-virtual-scroller
- 示例：

```js
// 虚拟列表
const VirtualList = {
  // 创建节点
  createNode() {
    const node = document.createElement('div');
    // ...添加样式
    return node;
  },
  // 渲染节点
  renderNode(node, data) {
    node.innerHTML = data;
  },
  // 复用节点
  reuseNode(node, data) {
    this.renderNode(node, data);
  },
  // 生成虚拟列表
  generateVirtualList(data) {
    const container = document.getElementById('container');
    const visibleCount = 20; // 可见区域节点数
    const nodes = []; // 节点池
    for (let i = 0; i < visibleCount; i++) {
      const node = this.createNode();
      container.appendChild(node);
      nodes.push(node);
    }
    let startIndex = 0; // 起始索引
    let endIndex = visibleCount; // 结束索引
    const render = () => {
      for (let i = startIndex; i < endIndex; i++) {
        const node = nodes[i - startIndex];
        this.reuseNode(node, data[i]);
      }
    };
    render();
    // 监听滚动
    container.addEventListener('scroll', () => {
      const scrollTop = container.scrollTop;
      startIndex = Math.floor(scrollTop / itemHeight);
      endIndex = startIndex + visibleCount;
      render();
    });
  },
};
```

#### 3.6.2 图标/图片/样式等资源复用

场景说明：
页面上有大量相同的图标、图片、样式等资源，如果每个都单独创建会浪费内存。
实现思路：
只创建一份资源（如 SVG 图标、图片对象、样式类），所有需要的地方都引用同一个实例。
例如 SVG `<use>` 标签、CSS 类名复用等。

#### 3.6.3 地图标记/大规模点位渲染

场景说明：
地图上有成千上万个点位（如高德、百度地图），每个点位都用同一个图标对象，只改变坐标和数据。

### 3.7 代理模式

:::tip
代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

前端开发中，代理模式（Proxy Pattern）的应用场景非常丰富，主要用于在访问对象时引入一个中间层（代理对象）以控制、增强或简化对目标对象的访问。代理可以在不改变原对象的前提下，增加额外的功能，如缓存、权限校验、延迟加载、数据劫持等。

优点：
增强对象功能，解耦业务逻辑
控制访问、优化性能、提升安全性
:::

#### 3.7.1 数据劫持与响应式（Vue2/3 响应式原理）

场景说明：
Vue3 使用 ES6 的 Proxy 实现响应式，拦截对象的 get/set 操作，实现数据自动追踪和更新。
示例：

```js
const data = { count: 0 };
const proxy = new Proxy(data, {
  get(target, key) {
    // 依赖收集
    return target[key];
  },
  set(target, key, value) {
    // 触发更新
    target[key] = value;
    // 通知视图更新
    return true;
  }
});
```

#### 3.7.2 接口请求代理（前端跨域/Mock）

场景说明：
开发环境下，前端通过本地代理服务器（如 webpack devServer、vite proxy）将 API 请求转发到后端，解决跨域问题，或拦截请求返回 mock 数据。
示例：

```js
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
}
```

#### 3.7.3 图片懒加载（IntersectionObserver）

场景说明：
图片还未加载完成时，先显示一张占位图，等图片加载好后再替换为真实图片。
实现思路：
用代理对象管理图片的加载和切换。当图片进入可视区域时，代理对象通知图片加载真实图片，并切换显示。

#### 3.7.4 缓存代理

场景说明：
对一些高开销的操作（如数据计算、接口请求），用代理缓存结果，避免重复计算或请求。
示例：

```js
function createCacheProxy(fn) {
  const cache = {};
  return function(arg) {
    if (cache[arg]) return cache[arg];
    return cache[arg] = fn(arg);
  }
}
```

#### 3.7.5 防抖/节流代理

场景说明：
对高频事件（如 scroll、resize、input）进行防抖/节流处理，避免频繁触发。
实现思路：
用代理函数包装原始事件处理函数。

#### 3.7.6 统计/埋点/日志代理

场景说明：
对用户行为（如点击、滚动、输入）进行统计/埋点/日志记录，以便后续分析。
实现思路：
用代理对象包装原始事件处理函数，在代理对象中添加统计/埋点/日志记录逻辑。
