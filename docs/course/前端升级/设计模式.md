# 设计模式

- <https://encode-studio-fe.github.io/design-pattern/creational/>

:::tip
用最少的人力成本满足构建和维护该系统的需求，再细致一些，就是支撑软件系统的全生命周期，让系统便于理解、易于修改、方便维护、轻松部署。
:::

## 0. 前言

设计原则： SOLID 原则是面向对象 class 设计的五条原则。

- S：单一职责原则（Single Responsibility Principle）；
- O：开闭原则（Open Closed Principie）；
- L：里氏替换原则（Liskov Substitution Principle）；
- I：接口隔离原则（Interface-segregation Principle）；
- D：依赖倒置原则（Dependency Inversion Principle）；

## 1. 介绍

### 1.1 是什么？

设计模式是软件设计中常见问题的典型解决方案。 它们就像能根据需求进行调整的预制蓝图， 可用于解决代码中反复出现的设计问题。

:::tip
算法更像是菜谱： 提供达成目标的明确步骤。 而模式更像是蓝图： 你可以看到最终的结果和模式的功能， 但需要自己确定实现步骤。
:::

### 1.2 分类

- **创建型模式**提供创建对象的机制， 增加已有代码的灵活性和可复用性，将创建和使用代码解耦；
- **结构型模式**介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效，将不同功能代码解构；
- **行为型模式**负责对象间的高效沟通和职责委派，不同的行为代码解构；

## 2. 创建式模式

:::tip
创建型模式提供创建对象的机制， 增加已有代码的灵活性和可复用性，将创建和使用代码解耦。
:::

### 2.1 单例模式

单例模式（Singleton Pattern）：保证一个类只有一个实例，并提供一个访问它的全局访问点。在前端开发中，可以使用单例模式来管理全局状态和资源。

现代单例模式实现：

```js
// MySingleton.js
// 在模块内部创建实例
class MySingleton {
  constructor() {
    if (MySingleton.instance) {
      return MySingleton.instance;
    }
    console.log("Singleton instance created.");
    // ... 初始化代码 ...
    MySingleton.instance = this;
  }

  // ... public methods ...
  doSomething() {
    console.log("Doing something...");
  }
}

// 导出这个唯一的实例
const instance = new MySingleton();
export default instance;
```

使用：

```js
import mySingletonInstance from "./MySingleton.js";

mySingletonInstance.doSomething(); // 输出: Singleton instance created. Doing something...
```

#### Q: ESM 中 export import 的实现是设计模式中的单例模式吗？

A: 不是，ESM 中的 export import 的实现是模块化设计模式中的模块模式。模块模式是一种设计模式，用于将代码组织成可重用的模块，每个模块都有自己的私有变量和函数，并且可以通过公开的接口与外部通信。模块模式可以用于创建单例对象，但是它并不是单例模式本身。模块的“单例”行为是其实现机制带来的一个自然结果，而不是它的首要设计目标。

### 2.2 建造者模式

建造者模式：是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。在前端开发中，可以使用建造者模式来构建复杂的对象，例如表单、对话框等。

:::tip
工厂类模式提供的是创建单个类的模式，而建造者模式则是将各种产品集中起来进行管理，用来创建复合对象，所谓复合对象就是指某个类具有不同的属性。
:::

建造者模式实现：表单实践

```js
class Form {
  constructor() {
    this.fields = [];
  }

  addField(field) {
    this.fields.push(field);
  }

  render() {
    const formElement = document.createElement("form");
    this.fields.forEach((field) => {
      formElement.appendChild(field.render());
    });
    return formElement;
  }
}

class Field {
  constructor(label, type, value) {
    this.label = label;
    this.type = type;
    this.value = value;
  }

  render() {
    const fieldElement = document.createElement("div");
    const labelElement = document.createElement("label");
    labelElement.textContent = this.label;
    const inputElement = document.createElement("input");
    inputElement.type = this.type;
    inputElement.value = this.value;
    fieldElement.appendChild(labelElement);
    fieldElement.appendChild(inputElement);
    return fieldElement;
  }
}

const form = new Form();
form.addField(new Field("Name", "text", "John"));
form.addField(new Field("Email", "email", "john@example.com"));

const formElement = form.render();
document.body.appendChild(formElement);
```

### 2.3 工厂模式

:::tip
工厂模式是一种创建型设计模式， 其在父类中提供一个创建对象的方法， 允许子类决定实例化对象的类型。
:::

工厂模式：是定义一个创建对象的接口，让子类决定实例化哪一个类。在前端开发中，可以使用工厂模式来创建不同类型的组件，例如按钮、输入框等。

工厂模式实现：按钮实践

```js
class Button {
  constructor(text) {
    this.text = text;
  }

  render() {
    const buttonElement = document.createElement("button");
    buttonElement.textContent = this.text;
    return buttonElement;
  }
}

class Link {
  constructor(url, text) {
    this.url = url;
    this.text = text;
  }

  render() {
    const linkElement = document.createElement("a");
    linkElement.href = this.url;
    linkElement.textContent = this.text;
    return linkElement;
  }
}

class UIComponentFactory {
  static createComponent(type, options) {
    switch (type) {
      case "button":
        return new Button(options.text);
      case "link":
        return new Link(options.url, options.text);
      default:
        throw new Error(`Unknown component type: ${type}`);
    }
  }
}

const button = UIComponentFactory.createComponent("button", {
  text: "Click me",
});
const link = UIComponentFactory.createComponent("link", {
  url: "https://example.com",
  text: "Example",
});
document.body.appendChild(button.render());
document.body.appendChild(link.render());
```

### 2.4 原型模式

原型模式：是使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。在前端开发中，可以使用原型模式来创建对象，例如克隆组件、克隆数据等。

原型模式实现：克隆数据实践

```js
const data = {
  name: "John",
  age: 30,
  address: {
    city: "New York",
    country: "USA",
  },
};

const clonedData = Object.assign({}, data);
clonedData.address = Object.assign({
  ...clonedData.address,
});
```

原型模式实现：克隆组件实践

```js
class Component {
  constructor(props) {
    this.props = props;
  }

  render() {
    // 渲染组件的逻辑
  }
}

class Button extends Component {
  constructor(props) {
    super(props);
  }

  render() {
    // 渲染按钮的逻辑
  }
}

const button = new Button({ text: "Click me" });
const clonedButton = Object.assign({}, button);
clonedButton.props = Object.assign({}, button.props);
```

### 2.5 抽象工厂模式

抽象工厂模式：是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。

:::tip
抽象工厂模式（Abstract Factory Pattern）的应用场景主要集中在需要创建一组相关或相互依赖的对象，并且不需要指定具体类的情况下。它常用于组件库、主题切换、跨平台适配等场景。
:::

#### 2.5.1 场景一（组件库的皮肤/主题切换）

组件库的皮肤/主题切换：例如，一个组件库需要支持多种皮肤或主题，可以使用抽象工厂模式来创建不同皮肤或主题的组件。

##### 说明

你有一套 UI 组件（如 Button、Input、Dialog），需要支持多套主题（如 light/dark、品牌 A/品牌 B），但不希望在业务代码中直接判断用哪个主题的组件。

##### 实现思路

定义一组抽象组件接口（如 IButton、IInput）。
每种主题实现一套具体组件（如 LightButton、DarkButton）。
用工厂类统一创建一组主题组件。

##### 示例

```js
// 抽象工厂
class ThemeFactory {
  createButton() {}
  createInput() {}
}

// 具体工厂
class LightThemeFactory extends ThemeFactory {
  createButton() {
    return new LightButton();
  }
  createInput() {
    return new LightInput();
  }
}
class DarkThemeFactory extends ThemeFactory {
  createButton() {
    return new DarkButton();
  }
  createInput() {
    return new DarkInput();
  }
}

// 使用
const factory = isDark ? new DarkThemeFactory() : new LightThemeFactory();
const btn = factory.createButton();
const input = factory.createInput();
```

#### 2.5.2 场景二（跨平台适配）

```txt
场景说明：
你要开发一套 UI，同时适配 Web、微信小程序、React Native 等不同平台，每个平台的组件实现方式不同，但业务层不想关心具体平台。
实现思路：
定义一组抽象组件接口。
每个平台实现一套具体组件。
用工厂类统一创建一组平台组件。
```

#### 2.5.3 场景三（表单控件的动态渲染）

```txt
场景说明：
你有一个表单生成器，根据不同的表单类型（如普通表单、搜索表单、弹窗表单）渲染不同风格的控件，但表单项类型是动态的。
实现思路：
定义抽象控件工厂。
不同表单类型实现不同的控件工厂。
通过工厂创建一组表单控件。
```

#### 2.5.4 场景四（国际化/多语言组件）

```txt
场景说明：
根据不同的语言环境，渲染不同的组件或内容（如中英文 Button、Dialog）。
实现思路：
定义抽象组件工厂。
每种语言实现一套具体组件。
用工厂统一创建。
```

#### 2.5.5 场景五（复杂业务场景下的“产品族”切换）

```txt
比如：
不同业务线（如电商/教育/医疗）有一套自己的 UI 组件和业务逻辑，但接口一致。
通过抽象工厂统一切换“产品族”。
```

#### 总结

抽象工厂模式在前端的典型应用场景：

- 主题/皮肤切换
- 跨平台组件适配
- 动态表单控件渲染
- 国际化组件
- 多业务线产品族切换

优点：

- 解耦业务与具体实现
- 易于扩展和维护
- 统一产品族的创建

### 2.6 生成器模式

生成器模式是一种创建型设计模式，允许使用相同的创建代码生成不同类型和形式的对象。

:::tip
前端开发中，生成器模式（建造者模式，Builder Pattern）的应用场景主要集中在需要分步骤构建一个复杂对象，并且构建过程可以灵活变化的场合。它可以让你用链式调用、分阶段配置等方式，优雅地创建复杂对象或结构。
:::

#### 2.6.1 场景一（表单/页面/组件的动态生成）

##### 1.场景说明

你需要根据配置动态生成表单、页面或复杂组件。表单项、校验规则、布局等都可以灵活配置。

##### 2.实现思路

定义一个抽象生成器接口。
每种表单类型实现具体生成器。
通过生成器统一创建表单。

##### 3.示例

```js
class FormBuilder {
  constructor() {
    this.form = { fields: [] };
  }
  addInput(name, label) {
    this.form.fields.push({ type: "input", name, label });
    return this;
  }
  addSelect(name, label, options) {
    this.form.fields.push({ type: "select", name, label, options });
    return this;
  }
  setLayout(layout) {
    this.form.layout = layout;
    return this;
  }
  build() {
    return this.form;
  }
}

// 使用
const form = new FormBuilder()
  .addInput("username", "用户名")
  .addInput("password", "密码")
  .addSelect("gender", "性别", ["男", "女"])
  .setLayout("horizontal")
  .build();
```

#### 2.6.2 场景二（配置对象的链式构建）

**场景说明**

如 axios、echarts、ant-design-vue 的 message、modal 等，很多库都支持链式配置参数，底层其实就是生成器模式。

**示例**

```js
const chart = new ChartBuilder()
  .setTitle("销量")
  .setXAxis(["1月", "2月"])
  .setSeries([100, 200])
  .build();
```

#### 2.6.3 场景三（富文本/虚拟 DOM/AST 的构建）

**场景说明：**
如 React.createElement、Vue 的 h 函数、AST 语法树的构建等，底层都可以用生成器模式来组织。

**示例：**

```js
const vnode = new VNodeBuilder()
  .setTag("div")
  .addClass("container")
  .addChild(new VNodeBuilder().setTag("span").setText("Hello").build())
  .build();
```

```js
// Vue 的 h 函数
const vnode = h("div", { class: "container" }, [h("span", "Hello")]);
```

```js
// AST 语法树的构建
const ast = new ASTBuilder()
  .setProgram(
    new ASTBuilder().setBody([
      new ASTBuilder().setExpressionStatement(
        new ASTBuilder().setExpression(
          new ASTBuilder().setMemberExpression(
            new ASTBuilder().setIdentifier("console"),
            new ASTBuilder().setIdentifier("log")
          ),
          new ASTBuilder().setLiteral("Hello World")
        )
      ),
    ])
  )
  .build();
```

#### 2.6.4 场景三（动态生成 CSS/样式对象）

**场景说明：**
如 styled-components、emotion 等 CSS-in-JS 库，底层也常用生成器模式来组织样式生成。

```js
// styled-components 的使用
const Button = styled.button`
  background: ${(props) => (props.primary ? "blue" : "gray")};
  color: white;
  padding: 10px;
`;
```

## 3. 结构型模式

:::tip
结构型模式介绍如何将对象和类组装成较大的结构， 并同时保持结构的灵活和高效。

降低耦合，提升复用、便于扩展和维护、让新旧系统/多端/多库无缝协作

:::

### 3.1 适配器模式

前端开发中，适配器模式（Adapter Pattern）的应用场景非常广泛，主要用于“接口转换”，即当你需要让一个已有对象/库/组件的接口与当前系统期望的接口兼容时，就可以用适配器模式。它的核心作用是“兼容老接口/第三方接口/不同风格接口”，让它们能无缝协作。

#### 3.1.1 场景一（第三方库/老系统接口适配）

**场景说明：**
你引入了一个第三方库或老系统的 API，但它的接口风格和你项目的接口不一致。

**解决方法：**
写一个适配器，把第三方接口“包一层”，转换成你项目需要的格式。

**示例：**

```js
// 第三方返回 { user_name: 'Tom', user_age: 18 }
function thirdPartyApi() {
  return { user_name: "Tom", user_age: 18 };
}

// 适配器
function userAdapter(raw) {
  return {
    name: raw.user_name,
    age: raw.user_age,
  };
}

// 使用
const user = userAdapter(thirdPartyApi()); // { name: 'Tom', age: 18 }
```

#### 3.1.2 场景二（统一多平台/多端 API）

**场景说明：**
你要让同一套业务代码适配 Web、微信小程序、React Native 等不同平台，但各平台 API 不一致。

**解决方法：**
为每个平台写一个适配器，暴露统一接口，业务层只用统一接口。

**示例：**

```js
// web-adapter.js
export function showToast(msg) { alert(msg); }

// wx-adapter.js
export function showToast(msg) { wx.showToast({ title: msg }); }

// platform-adapter.js
import { showToast as showToastWx } from './wx-adapter';
import { showToast as showToastWeb } from './web-adapter';

export function showToast(msg) {
  if (isWx) {
    showToastWx(msg);
  } else {
    showToastWeb(msg);
  }
}

// 业务代码
import { showToast } from './platform-adapter';
showToast('Hello');
```

#### 3.1.3 场景三（组件库二次封装）

**场景说明：**
你要基于 Element UI、Ant Design 等组件库，封装一套业务组件库，但业务组件库要求 API 和现有组件库不一致。

**解决方法：**
为每个组件库的组件写一个适配器，暴露统一接口，业务层只用统一接口。

**示例：**

```js
// element-adapter.js
import { Button as ElementButton } from 'element-ui';

export function Button(props) {
  return <ElementButton {...props} />;
}

// antd-adapter.js
import { Button as AntdButton } from 'antd';

export function Button(props) {
  return <AntdButton {...props} />;
}

// platform-adapter.js
import { Button as ButtonElement } from './element-adapter';
import { Button as ButtonAntd } from './antd-adapter';

export function Button(props) {
  if (isAntd) {
    return <ButtonAntd {...props} />;
  } else {
    return <ButtonElement {...props} />;
  }
}

// 业务代码
import { Button } from './platform-adapter';
<Button type="primary">Hello</Button>;
```

#### 3.1.4 场景四（数据格式转换）

场景说明：
后端返回的数据结构和前端展示的数据结构不一致。

解决方法：
写一个适配器函数，把后端数据转换成前端需要的格式。

示例：

```js
// adapter.js
export function adaptTableData(rawList) {
  return rawList.map(item => ({
    key: item.id,
    label: item.name,
    value: item.value
  }));
}

// 业务代码
import { adaptTableData } from './adapter';

const rawList = [
  { id: 1, name: 'A', value: 100 },
  { id: 2, name: 'B', value: 200 }
];

const adaptedList = adaptTableData(rawList);
```

#### 3.1.5 其他场景

- 统一事件/手势/输入适配

```txt
场景说明：
不同浏览器/设备的事件（如鼠标、触摸、手势）API 不一致。
解决方法：
写一个适配器，统一事件处理接口。
```

- 旧代码迁移/重构

```txt
场景说明：
你在重构老项目，想用新接口，但又不能马上全部替换。
解决方法：
写适配器，让新旧代码能共存，逐步迁移。
```

### 3.2 桥接模式

:::tip
桥接模式（Bridge Pattern）是一种结构型设计模式，它将抽象部分与实现部分分离，使它们可以独立变化。这种模式通过在抽象类中引入对实现类的引用，从而实现抽象类与实现类的解耦。

优点：
抽象与实现分离，便于独立扩展
支持多维度变化，避免类爆炸
降低耦合，提升灵活性
:::

前端开发中，桥接模式（Bridge Pattern）的应用场景主要是将抽象与实现解耦，使它们可以独立变化。桥接模式常用于多维度变化、平台适配、主题切换、渲染层分离等场景。

#### 3.2.1 主题与组件的解耦（主题切换）

- 场景说明：
你有一套 UI 组件（如 Button、Input），需要支持多套主题（如 light/dark），但不希望组件和主题实现强耦合。

- 桥接模式实现：
抽象部分：组件接口（如 Button）
实现部分：主题实现（如 LightTheme、DarkTheme）
组件通过桥接接口调用主题实现

- 示例：

```js
// 主题实现
class LightTheme { getColor() { return '#fff'; } }
class DarkTheme { getColor() { return '#000'; } }

// 抽象组件
class Button {
  constructor(theme) { this.theme = theme; }
  render() {
    return `<button style="background:${this.theme.getColor()}">按钮</button>`;
  }
}

// 使用
const btn = new Button(new DarkTheme());
btn.render();
```

#### 3.2.2 跨平台渲染（Web/Native/小程序）

```txt
场景说明：
你要开发一套业务逻辑，既能在 Web 上渲染，也能在小程序、Native 上渲染。
桥接模式实现：
抽象部分：业务逻辑
实现部分：不同平台的渲染实现
业务逻辑通过桥接接口调用不同平台的渲染
```

#### 3.2.3 图表/可视化渲染引擎解耦

```txt
场景说明：
你有一套图表 API，底层可能用 Canvas、SVG、WebGL 等不同渲染方式。
桥接模式实现：
抽象部分：图表 API
实现部分：不同渲染引擎
图表 API 通过桥接接口调用不同渲染引擎
```

#### 3.2.4 多维度产品族扩展

```txt
场景说明：
比如你有多种类型的消息（如 Email、短信、推送），每种消息又有多种发送渠道（如阿里云、腾讯云）。
桥接模式实现：
抽象部分：消息类型
实现部分：发送渠道
消息类型通过桥接接口调用不同渠道
```

### 3.3 组合模式

:::tip
组合模式是一种结构型设计模式， 你可以使用它将对象组合成树状结构， 并且能像使用独立对象一样使用它们。

前端开发中，组合模式（Composite Pattern）的应用场景非常广泛，主要用于将对象组合成树形结构以表示“部分-整体”的层次结构，并且让客户端可以统一地处理单个对象和对象集合。它非常适合处理递归结构、树形结构、嵌套结构等场景。

优点：
统一处理单个对象和对象集合
便于递归操作和渲染
结构灵活，易于扩展
:::

#### 3.3.1 前端组件树/虚拟DOM

- 场景说明：
React、Vue 等框架的组件树、虚拟DOM（VNode）本质上就是组合模式的应用。
叶子节点：普通组件、文本节点
组合节点：容器组件、父组件

- 示例：

```js
class Component {
  render() {}
}
class Leaf extends Component {
  render() { /* 渲染叶子节点 */ }
}
class Composite extends Component {
  constructor() { this.children = []; }
  add(child) { this.children.push(child); }
  render() {
    this.children.forEach(child => child.render());
  }
}
```

#### 3.3.2 菜单/树形控件/文件目录

- 场景说明：
如左侧菜单、文件目录、组织架构树等，都是树形结构，节点可以是文件（叶子）或文件夹（组合）。

- 示例：

```js
const menu = [
  { name: '首页' },
  { name: '文档', 
    children: [
      { name: 'API' },
      { name: '指南' }
    ]
  }
];
```

#### 3.3.3 表单/表单项嵌套

- 场景说明：
如 Ant Design 表单组件，表单项可以嵌套，如 Form.Item、Form.List 等。

#### 3.3.4 富文本/AST/JSON Schema

- 场景说明：
富文本编辑器的内容、AST 语法树、JSON Schema 等，都是递归嵌套结构，适合用组合模式遍历和操作。

#### 3.3.5 图形编辑器/画布对象

- 场景说明：
如画布上的图形对象，可以是单个图形（叶子），也可以是组合图形（组合节点），统一支持移动、缩放等操作。

#### 3.3.6 权限系统/组织架构

- 场景说明：
权限、组织架构等本质上是树形结构，适合用组合模式统一增删查改。

### 3.4 装饰模式

:::tip
装饰模式是一种结构型设计模式， 允许你通过将对象放入包含行为的特殊封装对象中来为原对象绑定新的行为。

前端开发中，装饰器模式（Decorator Pattern）的应用场景非常丰富，主要用于在不改变原有对象结构的情况下，动态地为对象添加功能。它可以让你灵活地为对象“包装”新能力，而无需修改原始代码。

优点：
不修改原有对象结构即可动态扩展功能
支持功能叠加、灵活组合
代码解耦、易于维护
:::

#### 3.4.1 组件增强（高阶组件 HOC）

- 场景说明：
在 React/Vue 等框架中，常用高阶组件（HOC）或“包装组件”来为原组件添加功能，比如权限校验、日志埋点、样式增强等。

- 示例：

```js
// React HOC 示例
function withLogger(WrappedComponent) {
  return function(props) {
    console.log('组件渲染', props);
    return <WrappedComponent {...props} />;
  }
}
const EnhancedComponent = withLogger(MyComponent);
```

#### 3.4.2 Vue 3 的自定义指令

- 场景说明：
通过自定义指令为 DOM 元素动态添加功能，比如 v-focus、v-copy、v-permission 等，本质上也是装饰器模式

#### 3.4.3 JavaScript ES7+ 装饰器语法

- 场景说明：
在类和方法上用 @decorator 语法动态增强功能，比如日志、缓存、权限、自动绑定等。

- 示例：

```js
function log(target, name, descriptor) {
  const oldValue = descriptor.value;
  descriptor.value = function(...args) {
    console.log(`调用${name}，参数:`, args);
    return oldValue.apply(this, args);
  }
  return descriptor;
}

class Demo {
  @log
  say(msg) { console.log(msg); }
}
```

#### 3.4.4 事件处理增强

- 场景说明：
通过装饰器为事件处理函数动态添加功能，比如防抖、节流、错误处理等。

- 示例：

```js
function debounce(fn, delay) {
  let timer;
  return function(...args) {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, args), delay);
  }
}
const onInput = debounce(function(e) { /* ... */ }, 300);
```

#### 3.4.5 其他

- 请求/响应拦截器

```txt
场景说明：
如 axios 的请求/响应拦截器，可以为请求动态添加 token、日志、错误处理等功能。
```

- 样式/动画增强

```txt
场景说明：
为组件或 DOM 元素动态添加样式、动画、过渡等效果。
```

- 业务功能动态扩展

```txt
场景说明：
如表单校验、权限校验、埋点统计等，可以通过装饰器模式为原有功能动态扩展。
```

### 3.5 外观模式

:::tip
外观模式是一种结构型设计模式， 能为程序库、 框架或其他复杂类提供一个简单的接口。

前端开发中，外观模式（Facade Pattern）的应用场景非常常见。外观模式的核心作用是为复杂子系统提供一个统一的简化接口，让调用者无需关心内部细节，只需通过“外观”对象即可完成复杂操作。
:::

#### 3.5.1 封装复杂的 API/SDK 调用

- 场景说明：
第三方 SDK（如地图、支付、富文本、播放器等）通常有很多初始化、配置、事件绑定等繁琐步骤。
外观模式做法：
封装成一个简单的接口，业务方只需一行代码即可完成复杂操作。

- 示例：

```js
// 外观
class MapFacade {
  constructor(containerId) {
    this.map = new MapSDK(containerId);
    this.map.init();
    this.map.setDefaultStyle();
    // ...各种初始化
  }
  setCenter(lat, lng) {
    this.map.setCenter({ lat, lng });
  }
  addMarker(lat, lng) {
    this.map.addMarker({ lat, lng });
  }
}
// 使用
const map = new MapFacade('map-container');
map.setCenter(39.9, 116.4);
map.addMarker(39.9, 116.4);
```

#### 3.5.2 统一管理浏览器兼容性问题

- 场景说明：
不同浏览器的 API 差异大，直接操作容易出错。
外观模式做法：
封装一组统一的接口，内部自动适配不同浏览器。

- 示例：

```js
const EventUtil = {
  addEvent(element, type, handler) {
    if (element.addEventListener) {
      element.addEventListener(type, handler);
    } else {
      element.attachEvent('on' + type, handler);
    }
  },
  // ...更多兼容性方法
};
// 使用
EventUtil.addEvent(element, 'click', handler);
```

#### 3.5.3 统一封装本地存储/统一封装网络请求

- 场景说明：
localStorage、sessionStorage、cookie 操作繁琐且 API 不统一。
外观模式做法：
封装成 StorageFacade，提供统一的 get/set/remove 接口。

- 示例：

```js
const StorageFacade = {
  set(key, value) {
    localStorage.setItem(key, JSON.stringify(value));
  },
  get(key) {
    return JSON.parse(localStorage.getItem(key));
  },
  remove(key) {
    localStorage.removeItem(key);
  }
};
```

### 3.6 享元模式

:::tip
享元模式是一种结构型设计模式， 它摒弃了在每个对象中保存所有数据的方式， 通过共享多个对象所共有的相同状态， 让你能在有限的内存容量中载入更多对象。

前端开发中，享元模式（Flyweight Pattern）的应用场景主要集中在需要大量创建相似对象、对象数量巨大、内存优化的场合。享元模式的核心思想是共享内部状态，减少对象数量，节省内存。
:::

#### 3.6.1 虚拟列表/大数据量渲染

- 场景说明：
如长列表、表格、无限滚动等场景，页面上可能有成千上万个数据项，但实际只渲染可视区域的少量 DOM 节点，复用这些节点来显示不同数据。
- 实现思路：
只创建和维护可视区域需要的 DOM 元素（如 20 个），滚动时复用这些元素，改变其内容和位置。
这就是享元模式的典型应用：节点对象被复用，数据是外部状态。
- 相关库：
react-window、vue-virtual-scroller
- 示例：

```js
// 虚拟列表
const VirtualList = {
  // 创建节点
  createNode() {
    const node = document.createElement('div');
    // ...添加样式
    return node;
  },
  // 渲染节点
  renderNode(node, data) {
    node.innerHTML = data;
  },
  // 复用节点
  reuseNode(node, data) {
    this.renderNode(node, data);
  },
  // 生成虚拟列表
  generateVirtualList(data) {
    const container = document.getElementById('container');
    const visibleCount = 20; // 可见区域节点数
    const nodes = []; // 节点池
    for (let i = 0; i < visibleCount; i++) {
      const node = this.createNode();
      container.appendChild(node);
      nodes.push(node);
    }
    let startIndex = 0; // 起始索引
    let endIndex = visibleCount; // 结束索引
    const render = () => {
      for (let i = startIndex; i < endIndex; i++) {
        const node = nodes[i - startIndex];
        this.reuseNode(node, data[i]);
      }
    };
    render();
    // 监听滚动
    container.addEventListener('scroll', () => {
      const scrollTop = container.scrollTop;
      startIndex = Math.floor(scrollTop / itemHeight);
      endIndex = startIndex + visibleCount;
      render();
    });
  },
};
```

#### 3.6.2 图标/图片/样式等资源复用

场景说明：
页面上有大量相同的图标、图片、样式等资源，如果每个都单独创建会浪费内存。
实现思路：
只创建一份资源（如 SVG 图标、图片对象、样式类），所有需要的地方都引用同一个实例。
例如 SVG `<use>` 标签、CSS 类名复用等。

#### 3.6.3 地图标记/大规模点位渲染

场景说明：
地图上有成千上万个点位（如高德、百度地图），每个点位都用同一个图标对象，只改变坐标和数据。

### 3.7 代理模式

:::tip
代理模式是一种结构型设计模式， 让你能够提供对象的替代品或其占位符。 代理控制着对于原对象的访问， 并允许在将请求提交给对象前后进行一些处理。

前端开发中，代理模式（Proxy Pattern）的应用场景非常丰富，主要用于在访问对象时引入一个中间层（代理对象）以控制、增强或简化对目标对象的访问。代理可以在不改变原对象的前提下，增加额外的功能，如缓存、权限校验、延迟加载、数据劫持等。

优点：
增强对象功能，解耦业务逻辑
控制访问、优化性能、提升安全性
:::

#### 3.7.1 数据劫持与响应式（Vue2/3 响应式原理）

场景说明：
Vue3 使用 ES6 的 Proxy 实现响应式，拦截对象的 get/set 操作，实现数据自动追踪和更新。
示例：

```js
const data = { count: 0 };
const proxy = new Proxy(data, {
  get(target, key) {
    // 依赖收集
    return target[key];
  },
  set(target, key, value) {
    // 触发更新
    target[key] = value;
    // 通知视图更新
    return true;
  }
});
```

#### 3.7.2 接口请求代理（前端跨域/Mock）

场景说明：
开发环境下，前端通过本地代理服务器（如 webpack devServer、vite proxy）将 API 请求转发到后端，解决跨域问题，或拦截请求返回 mock 数据。
示例：

```js
// vite.config.js
export default {
  server: {
    proxy: {
      '/api': 'http://localhost:3000'
    }
  }
}
```

#### 3.7.3 图片懒加载（IntersectionObserver）

场景说明：
图片还未加载完成时，先显示一张占位图，等图片加载好后再替换为真实图片。
实现思路：
用代理对象管理图片的加载和切换。当图片进入可视区域时，代理对象通知图片加载真实图片，并切换显示。

#### 3.7.4 缓存代理

场景说明：
对一些高开销的操作（如数据计算、接口请求），用代理缓存结果，避免重复计算或请求。
示例：

```js
function createCacheProxy(fn) {
  const cache = {};
  return function(arg) {
    if (cache[arg]) return cache[arg];
    return cache[arg] = fn(arg);
  }
}
```

#### 3.7.5 防抖/节流代理

场景说明：
对高频事件（如 scroll、resize、input）进行防抖/节流处理，避免频繁触发。
实现思路：
用代理函数包装原始事件处理函数。

#### 3.7.6 统计/埋点/日志代理

场景说明：
对用户行为（如点击、滚动、输入）进行统计/埋点/日志记录，以便后续分析。
实现思路：
用代理对象包装原始事件处理函数，在代理对象中添加统计/埋点/日志记录逻辑。

## 4. 行为型模式

:::tip
行为模式负责对象间的高效沟通和职责委派。
:::

### 4.1 责任链模式

:::tip
允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

前端开发中，责任链模式（Chain of Responsibility Pattern）的应用场景主要集中在请求处理流程、事件处理、中间件机制等场景。责任链模式的核心思想是将请求的发送者和接收者解耦，让多个对象都有机会处理请求，直到有一个对象处理它为止。

优点：
降低耦合度，增加灵活性
动态组合处理流程
易于扩展和维护
:::

#### 4.1.1 表单验证链

场景说明：
表单提交时需要经过多个验证步骤（如必填验证、格式验证、长度验证、业务验证等），每个验证器都可以处理请求或传递给下一个验证器。
示例：

```js
class Validator {
  constructor() {
    this.next = null;
  }
  setNext(validator) {
    this.next = validator;
    return validator;
  }
  validate(data) {
    if (this.next) {
      return this.next.validate(data);
    }
    return true;
  }
}

class RequiredValidator extends Validator {
  validate(data) {
    if (!data.value) {
      return { error: '必填项不能为空' };
    }
    return super.validate(data);
  }
}

class EmailValidator extends Validator {
  validate(data) {
    if (data.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.value)) {
      return { error: '邮箱格式不正确' };
    }
    return super.validate(data);
  }
}

// 使用
const chain = new RequiredValidator();
chain.setNext(new EmailValidator());
const result = chain.validate({ value: 'test', type: 'email' });
```

#### 4.1.2 中间件机制（Express.js、Koa.js）

场景说明：
Node.js 框架中的中间件机制就是责任链模式的典型应用。每个中间件都可以处理请求，或者调用 next() 传递给下一个中间件。
示例：

```js
// Express.js 中间件
app.use((req, res, next) => {
  console.log('中间件1');
  next(); // 传递给下一个中间件
});

app.use((req, res, next) => {
  console.log('中间件2');
  next();
});

app.get('/', (req, res) => {
  res.send('Hello');
});
```

#### 4.1.3 事件处理链

场景说明：
DOM 事件处理中的事件冒泡机制，事件会沿着 DOM 树向上传播，每个节点都有机会处理事件。
示例：

```js
// 事件处理链
document.addEventListener('click', (e) => {
  console.log('Document 处理点击事件');
  // 可以选择阻止事件继续传播
  // e.stopPropagation();
});

document.body.addEventListener('click', (e) => {
  console.log('Body 处理点击事件');
});
```

### 4.2 命令模式

可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

### 4.3 迭代器模式

能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

### 4.4 中介者模式

减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。

### 4.5 备忘录模式

允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

### 4.6 观察者模式

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

### 4.7 状态模式

能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

### 4.8 策略模式

能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

### 4.9 模板方法模式

在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。

### 4.10 访问者模式

能将算法与其所作用的对象隔离开来。
