# 设计模式之行为型

## 4. 行为型模式

:::tip
行为模式负责对象间的高效沟通和职责委派。
:::

### 4.1 责任链模式

:::tip
允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

前端开发中，责任链模式（Chain of Responsibility Pattern）的应用场景主要集中在请求处理流程、事件处理、中间件机制等场景。责任链模式的核心思想是将请求的发送者和接收者解耦，让多个对象都有机会处理请求，直到有一个对象处理它为止。

优点：
降低耦合度，增加灵活性
动态组合处理流程
易于扩展和维护
:::

#### 4.1.1 表单验证链

场景说明：
表单提交时需要经过多个验证步骤（如必填验证、格式验证、长度验证、业务验证等），每个验证器都可以处理请求或传递给下一个验证器。
示例：

```js
class Validator {
  constructor() {
    this.next = null;
  }
  setNext(validator) {
    this.next = validator;
    return validator;
  }
  validate(data) {
    if (this.next) {
      return this.next.validate(data);
    }
    return true;
  }
}

class RequiredValidator extends Validator {
  validate(data) {
    if (!data.value) {
      return { error: '必填项不能为空' };
    }
    return super.validate(data);
  }
}

class EmailValidator extends Validator {
  validate(data) {
    if (data.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.value)) {
      return { error: '邮箱格式不正确' };
    }
    return super.validate(data);
  }
}

// 使用
const chain = new RequiredValidator();
chain.setNext(new EmailValidator());
const result = chain.validate({ value: 'test', type: 'email' });
```

#### 4.1.2 中间件机制（Express.js、Koa.js）

场景说明：
Node.js 框架中的中间件机制就是责任链模式的典型应用。每个中间件都可以处理请求，或者调用 next() 传递给下一个中间件。
示例：

```js
// Express.js 中间件
app.use((req, res, next) => {
  console.log('中间件1');
  next(); // 传递给下一个中间件
});

app.use((req, res, next) => {
  console.log('中间件2');
  next();
});

app.get('/', (req, res) => {
  res.send('Hello');
});
```

#### 4.1.3 事件处理链

场景说明：
DOM 事件处理中的事件冒泡机制，事件会沿着 DOM 树向上传播，每个节点都有机会处理事件。
示例：

```js
// 事件处理链
document.addEventListener('click', (e) => {
  console.log('Document 处理点击事件');
  // 可以选择阻止事件继续传播
  // e.stopPropagation();
});

document.body.addEventListener('click', (e) => {
  console.log('Body 处理点击事件');
});
```

### 4.2 命令模式

可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

:::tip
前端开发中，命令模式（Command Pattern）的应用场景非常丰富。命令模式的核心思想是将请求封装成对象，从而可以用不同的请求对客户进行参数化，对请求排队或记录请求日志，以及支持可撤销的操作。

优点：
解耦请求发送者和接收者
支持撤销和重做操作
支持命令队列和宏命令
易于扩展新的命令类型
:::

#### 4.2.1 撤销/重做功能（编辑器、画布应用）

**场景说明：**
在富文本编辑器、画布应用、代码编辑器等场景中，用户需要能够撤销和重做操作。

**示例：**

```js
// 将用户操作封装成命令对象，支持历史记录和状态回退
// 每个命令都需要保存执行前的状态，以便撤销时恢复
// 命令接口
class Command {
  execute() {}
  undo() {}
}

// 具体命令：添加文本
class AddTextCommand extends Command {
  constructor(editor, text, position) {
    super();
    this.editor = editor;
    this.text = text;
    this.position = position;
    this.previousContent = '';
  }

  execute() {
    this.previousContent = this.editor.getContent();
    this.editor.insertText(this.text, this.position);
  }

  undo() {
    this.editor.setContent(this.previousContent);
  }
}

// 具体命令：删除文本
class DeleteTextCommand extends Command {
  constructor(editor, start, end) {
    super();
    this.editor = editor;
    this.start = start;
    this.end = end;
    this.deletedText = '';
  }

  execute() {
    this.deletedText = this.editor.getText(this.start, this.end);
    this.editor.deleteText(this.start, this.end);
  }

  undo() {
    this.editor.insertText(this.deletedText, this.start);
  }
}

// 编辑器类
class Editor {
  constructor() {
    this.content = '';
    this.commandHistory = [];
    this.currentIndex = -1;
  }

  insertText(text, position) {
    this.content = this.content.slice(0, position) + text + this.content.slice(position);
  }

  deleteText(start, end) {
    this.content = this.content.slice(0, start) + this.content.slice(end);
  }

  getContent() {
    return this.content;
  }

  setContent(content) {
    this.content = content;
  }

  getText(start, end) {
    return this.content.slice(start, end);
  }

  executeCommand(command) {
    command.execute();
    // 清除当前位置之后的历史记录
    this.commandHistory = this.commandHistory.slice(0, this.currentIndex + 1);
    this.commandHistory.push(command);
    this.currentIndex++;
  }

  undo() {
    if (this.currentIndex >= 0) {
      this.commandHistory[this.currentIndex].undo();
      this.currentIndex--;
    }
  }

  redo() {
    if (this.currentIndex < this.commandHistory.length - 1) {
      this.currentIndex++;
      this.commandHistory[this.currentIndex].execute();
    }
  }
}

// 使用示例
const editor = new Editor();
const addCommand = new AddTextCommand(editor, 'Hello', 0);
const deleteCommand = new DeleteTextCommand(editor, 0, 5);

editor.executeCommand(addCommand); // 添加 "Hello"
console.log(editor.getContent()); // "Hello"

editor.executeCommand(deleteCommand); // 删除 "Hello"
console.log(editor.getContent()); // ""

editor.undo(); // 撤销删除
console.log(editor.getContent()); // "Hello"

editor.redo(); // 重做删除
console.log(editor.getContent()); // ""
```

#### 4.2.2 宏命令（批量操作）

**场景说明：**
将多个命令组合成一个宏命令，实现批量操作。

**示例：**

```js
// 将多个命令组合成一个宏命令，实现批量处理
// 按顺序执行，按逆序撤销
class MacroCommand extends Command {
  constructor() {
    super();
    this.commands = [];
  }

  add(command) {
    this.commands.push(command);
  }

  execute() {
    this.commands.forEach(command => command.execute());
  }

  undo() {
    // 按相反顺序撤销
    for (let i = this.commands.length - 1; i >= 0; i--) {
      this.commands[i].undo();
    }
  }
}

// 使用示例
const macro = new MacroCommand();
macro.add(new AddTextCommand(editor, 'Hello ', 0));
macro.add(new AddTextCommand(editor, 'World!', 6));

editor.executeCommand(macro);
console.log(editor.getContent()); // "Hello World!"

editor.undo(); // 撤销整个宏命令
console.log(editor.getContent()); // ""
```

#### 4.2.3 命令队列（异步操作）

**场景说明：**
将命令放入队列中，支持异步执行和延迟执行。

**示例：**

```js
// 队列管理和异步执行控制
class CommandQueue {
  constructor() {
    this.queue = [];
    this.isProcessing = false;
  }

  add(command) {
    this.queue.push(command);
    if (!this.isProcessing) {
      this.process();
    }
  }

  async process() {
    this.isProcessing = true;
    while (this.queue.length > 0) {
      const command = this.queue.shift();
      await command.execute();
      // 可以添加延迟
      await new Promise(resolve => setTimeout(resolve, 100));
    }
    this.isProcessing = false;
  }
}

// 异步命令示例
class AsyncCommand extends Command {
  constructor(delay, message) {
    super();
    this.delay = delay;
    this.message = message;
  }

  async execute() {
    await new Promise(resolve => setTimeout(resolve, this.delay));
    console.log(this.message);
  }

  undo() {
    console.log(`撤销: ${this.message}`);
  }
}

// 使用示例
const queue = new CommandQueue();
queue.add(new AsyncCommand(1000, '第一个命令'));
queue.add(new AsyncCommand(500, '第二个命令'));
queue.add(new AsyncCommand(800, '第三个命令'));
```

#### 4.2.4 UI 操作封装（按钮、菜单）

**场景说明：**
将 UI 操作封装成命令，实现按钮、菜单等控件的统一处理。

**示例：**

```js
// 命令对象封装具体的业务逻辑
// UI 命令基类
class UICommand extends Command {
  constructor(receiver) {
    super();
    this.receiver = receiver;
  }
}

// 具体 UI 命令
class SaveCommand extends UICommand {
  execute() {
    this.receiver.save();
  }

  undo() {
    this.receiver.restore();
  }
}

class CopyCommand extends UICommand {
  execute() {
    this.receiver.copy();
  }

  undo() {
    // 复制操作通常不需要撤销
  }
}

class PasteCommand extends UICommand {
  constructor(receiver, clipboard) {
    super(receiver);
    this.clipboard = clipboard;
    this.previousContent = '';
  }

  execute() {
    this.previousContent = this.receiver.getContent();
    this.receiver.paste(this.clipboard.getContent());
  }

  undo() {
    this.receiver.setContent(this.previousContent);
  }
}

// 接收者
class Document {
  constructor() {
    this.content = '';
    this.backup = '';
  }

  save() {
    this.backup = this.content;
    console.log('文档已保存');
  }

  restore() {
    this.content = this.backup;
    console.log('文档已恢复');
  }

  copy() {
    console.log('内容已复制到剪贴板');
  }

  paste(content) {
    this.content += content;
    console.log('内容已粘贴');
  }

  getContent() {
    return this.content;
  }

  setContent(content) {
    this.content = content;
  }
}

// 按钮类
class Button {
  constructor(command) {
    this.command = command;
  }

  click() {
    this.command.execute();
  }
}

// 使用示例
const document = new Document();
const clipboard = { getContent: () => 'Hello World!' };

const saveButton = new Button(new SaveCommand(document));
const copyButton = new Button(new CopyCommand(document));
const pasteButton = new Button(new PasteCommand(document, clipboard));

saveButton.click(); // 文档已保存
copyButton.click(); // 内容已复制到剪贴板
pasteButton.click(); // 内容已粘贴
```

#### 4.2.5 路由命令（SPA 应用）

**场景说明：**
在单页面应用中，将路由跳转封装成命令，支持前进、后退功能。

**示例：**

```js
// 保存导航历史，支持状态回退
class RouteCommand extends Command {
  constructor(router, path, params = {}) {
    super();
    this.router = router;
    this.path = path;
    this.params = params;
    this.previousPath = '';
  }

  execute() {
    this.previousPath = this.router.currentPath;
    this.router.navigate(this.path, this.params);
  }

  undo() {
    this.router.navigate(this.previousPath);
  }
}

class Router {
  constructor() {
    this.currentPath = '/';
    this.history = [];
  }

  navigate(path, params = {}) {
    this.currentPath = path;
    console.log(`导航到: ${path}`, params);
    // 实际的导航逻辑
  }
}

// 使用示例
const router = new Router();
const homeCommand = new RouteCommand(router, '/home');
const aboutCommand = new RouteCommand(router, '/about');

homeCommand.execute(); // 导航到: /home
aboutCommand.execute(); // 导航到: /about
aboutCommand.undo(); // 导航到: /home
```

#### 4.2.6 表单操作命令

**场景说明：**
将表单操作（如提交、重置、验证）封装成命令。

**示例：**

```js
// 存表单状态，支持数据恢复
class FormCommand extends Command {
  constructor(form) {
    super();
    this.form = form;
  }
}

class SubmitFormCommand extends FormCommand {
  constructor(form, onSubmit) {
    super(form);
    this.onSubmit = onSubmit;
    this.previousData = {};
  }

  execute() {
    this.previousData = { ...this.form.getData() };
    this.onSubmit(this.form.getData());
  }

  undo() {
    this.form.setData(this.previousData);
  }
}

class ResetFormCommand extends FormCommand {
  constructor(form) {
    super(form);
    this.previousData = {};
  }

  execute() {
    this.previousData = { ...this.form.getData() };
    this.form.reset();
  }

  undo() {
    this.form.setData(this.previousData);
  }
}

class Form {
  constructor() {
    this.data = {};
  }

  getData() {
    return this.data;
  }

  setData(data) {
    this.data = data;
  }

  reset() {
    this.data = {};
  }
}

// 使用示例
const form = new Form();
form.setData({ name: 'John', email: 'john@example.com' });

const submitCommand = new SubmitFormCommand(form, (data) => {
  console.log('提交表单:', data);
});

const resetCommand = new ResetFormCommand(form);

submitCommand.execute(); // 提交表单: { name: 'John', email: 'john@example.com' }
submitCommand.undo(); // 恢复表单数据

resetCommand.execute(); // 重置表单
resetCommand.undo(); // 恢复表单数据
```

### 4.3 迭代器模式

能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

:::tip
前端中的迭代器模式不止用于数组遍历，还用于分页拉取、树结构/虚拟 DOM 遍历、流式处理、异步拉取等。核心是“以统一方式顺序访问对象内部元素，而不暴露内部结构”。
:::

#### 4.3.1 自定义可迭代对象（Symbol.iterator）

```js
// 将业务对象暴露为 for...of 可遍历
const collection = {
  items: [1, 2, 3],
  [Symbol.iterator]() {
    let index = 0;
    const items = this.items;
    return {
      next() {
        if (index < items.length) {
          return { value: items[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    }
  }
}

for (const n of collection) {
  console.log(n);
}
```

#### 4.3.2 生成器作为迭代器（同步）

```js
// 用生成器将复杂遍历逻辑封装为易用的迭代器
function* range(start, end, step = 1) {
  for (let i = start; i <= end; i += step) {
    yield i;
  }
}

for (const n of range(1, 5)) {
  console.log(n);
}
```

#### 4.3.3 树/DOM/虚拟 DOM 的遍历

```js
// 深度优先遍历树结构（可用于菜单、路由树、虚拟 DOM 等）
function* dfs(node) {
  if (!node) return;
  yield node;
  if (node.children) {
    for (const child of node.children) {
      yield* dfs(child);
    }
  }
}

const tree = { id: 1, children: [{ id: 2 }, { id: 3, children: [{ id: 4 }] }] };
for (const node of dfs(tree)) {
  console.log(node.id);
}
```

```js
// 原生 DOM 也内置了 NodeIterator / TreeWalker 可迭代访问
const walker = document.createTreeWalker(document.body, NodeFilter.SHOW_ELEMENT);
let current = walker.currentNode;
while (current) {
  // 访问元素节点
  current = walker.nextNode();
}
```

#### 4.3.4 分页数据迭代器（拉取更多/无限滚动）

```js
// 统一分页访问，调用方不关心内部分页细节
class PagedFetcher {
  constructor(fetchPage) {
    this.fetchPage = fetchPage; // (page) => Promise<{ list, hasMore }>
  }
  [Symbol.asyncIterator]() {
    let page = 1;
    let buffer = [];
    let hasMore = true;
    const fetchPage = this.fetchPage;
    return {
      async next() {
        if (buffer.length === 0 && hasMore) {
          const { list, hasMore: more } = await fetchPage(page++);
          buffer = list;
          hasMore = more;
        }
        if (buffer.length > 0) {
          return { value: buffer.shift(), done: false };
        }
        return { value: undefined, done: true };
      }
    }
  }
}

// 使用：for await...of 可逐条消费分页数据
async function run() {
  const iter = new PagedFetcher(async (page) => {
    const res = await fetch(`/api/items?page=${page}`).then(r => r.json());
    return { list: res.items, hasMore: res.hasMore };
  });

  for await (const item of iter) {
    console.log('item', item);
  }
}
```

#### 4.3.5 游标/流式读取（AsyncIterator）

```js
// 例如读取大型文件/流，按块异步迭代
async function* streamChunks(readableStream) {
  const reader = readableStream.getReader();
  try {
    while (true) {
      const { value, done } = await reader.read();
      if (done) break;
      yield value; // Uint8Array chunk
    }
  } finally {
    reader.releaseLock();
  }
}

// for await 按块消费，适用于解析大 JSON、日志、导入进度等
// for await (const chunk of streamChunks(resp.body)) { ... }
```

#### 4.3.6 组合与扁平化迭代

```js
// 将多个可迭代对象合并为单个迭代器
function* concat(...iters) {
  for (const it of iters) {
    yield* it;
  }
}

const a = [1, 2];
const b = new Set([3, 4]);
for (const x of concat(a, b)) {
  console.log(x); // 1 2 3 4
}
```

### 4.4 中介者模式

减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。

:::tip
中介者模式通过“中心调度者”来协调多个对象（组件/模块）之间的交互，避免它们互相直接引用导致的网状依赖。常用于组件通信、模块编排、弹窗/状态协调、房间/频道等场景。
:::

#### 4.4.1 组件间通信的中介者（去中心化 EventBus 的集中治理）

```js
// 简化版中介者：集中注册组件，转发消息
class Mediator {
  constructor() {
    this.participants = new Map();
  }
  register(name, participant) {
    this.participants.set(name, participant);
    participant.mediator = this;
  }
  send(from, to, message, payload) {
    const target = this.participants.get(to);
    if (target && typeof target.receive === 'function') {
      target.receive({ from, message, payload });
    }
  }
}

class Component {
  constructor(name) {
    this.name = name;
    this.mediator = null;
  }
  emit(to, message, payload) {
    this.mediator?.send(this.name, to, message, payload);
  }
  receive({ from, message, payload }) {
    console.log(`[${this.name}] <- ${from}: ${message}`, payload);
  }
}

// 使用示例：A/B/C 组件通过中介者协作
const mediator = new Mediator();
const A = new Component('A');
const B = new Component('B');
const C = new Component('C');
mediator.register('A', A);
mediator.register('B', B);
mediator.register('C', C);

A.emit('B', 'update', { id: 1 });
B.emit('C', 'refresh');
```

#### 4.4.2 表单字段联动协调器

```js
// 当一个字段变化时，其他字段的可见性、校验、选项需要联动
class FormMediator {
  constructor(fields) {
    this.fields = fields; // Map<string, Field>
  }
  notify(sender, event, data) {
    if (sender === 'country' && event === 'change') {
      const province = this.fields.get('province');
      province.setVisible(!!data);
      province.reset();
    }
    if (sender === 'type' && event === 'change') {
      const advanced = this.fields.get('advancedOptions');
      advanced.setEnabled(data === 'advanced');
    }
  }
}

class Field {
  constructor(name, mediator) {
    this.name = name;
    this.mediator = mediator;
    this.visible = true;
    this.enabled = true;
    this.value = undefined;
  }
  change(value) {
    this.value = value;
    this.mediator.notify(this.name, 'change', value);
  }
  setVisible(v) { this.visible = v; }
  setEnabled(v) { this.enabled = v; }
  reset() { this.value = undefined; }
}

// 使用
const fields = new Map();
const formMediator = new FormMediator(fields);
fields.set('country', new Field('country', formMediator));
fields.set('province', new Field('province', formMediator));
fields.set('type', new Field('type', formMediator));
fields.set('advancedOptions', new Field('advancedOptions', formMediator));

fields.get('country').change('CN'); // 省份可见并重置
fields.get('type').change('advanced'); // 高级选项可用
```

#### 4.4.3 模态框/全局弹层管理器

```js
class ModalMediator {
  constructor() {
    this.modals = new Map();
    this.stack = [];
  }
  register(name, api) { this.modals.set(name, api); }
  open(name, props) {
    const api = this.modals.get(name);
    if (!api) return;
    if (this.stack.length) this.modals.get(this.stack.at(-1))?.blur?.();
    this.stack.push(name);
    api.open(props);
  }
  close() {
    const name = this.stack.pop();
    this.modals.get(name)?.close();
    this.modals.get(this.stack.at(-1))?.focus?.();
  }
}

// 使用：各个弹窗无需彼此知道，只与中介者交互
const modal = new ModalMediator();
modal.register('confirm', { open: (p)=>{/*...*/}, close: ()=>{/*...*/} });
modal.register('detail', { open: (p)=>{/*...*/}, close: ()=>{/*...*/} });
modal.open('confirm', { title: '确定删除？' });
```

#### 4.4.4 房间/频道中介（WebSocket/协同）

```js
class RoomMediator {
  constructor() {
    this.members = new Set();
  }
  join(client) { this.members.add(client); client.mediator = this; }
  leave(client) { this.members.delete(client); }
  broadcast(from, event, data) {
    for (const m of this.members) {
      if (m !== from) m.receive(event, data);
    }
  }
}

class Client {
  constructor(id) { this.id = id; this.mediator = null; }
  send(event, data) { this.mediator?.broadcast(this, event, data); }
  receive(event, data) { console.log(this.id, event, data); }
}

const room = new RoomMediator();
const u1 = new Client('u1');
const u2 = new Client('u2');
room.join(u1); room.join(u2);
u1.send('typing', { at: Date.now() });
```

#### 4.4.5 页面模块编排（仪表盘/看板）

```js
// 各卡片只与调度中心通信，不互相调用
class DashboardMediator {
  constructor() { this.widgets = new Map(); }
  register(name, widget) { this.widgets.set(name, widget); widget.mediator = this; }
  notify(sender, event, payload) {
    if (sender === 'filter' && event === 'change') {
      this.widgets.get('chart')?.update(payload);
      this.widgets.get('table')?.update(payload);
    }
  }
}
```

#### 4.4.6 适用与收益

- 解耦组件/模块依赖，降低修改牵引面
- 统一调度与可观测性更强，便于日志/埋点/权限集中治理
- 更易于测试：替换中介者即可隔离交互

### 4.5 备忘录模式

允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

:::tip
备忘录模式用于“快照与恢复”。与命令模式侧重“可撤销操作步骤”不同，备忘录模式侧重“保存状态快照并在需要时恢复”。适用于表单草稿、画布/编辑器快照、乐观更新回滚、全局设置恢复、复杂向导/步骤回退等。
:::

#### 4.5.1 基础实现（Originator / Memento / Caretaker）

```js
// Originator: 负责创建和恢复自身状态
class Editor {
  constructor() {
    this.content = '';
    this.selection = { start: 0, end: 0 };
  }
  type(text) { this.content = this.content + text; }
  setSelection(start, end) { this.selection = { start, end }; }
  createMemento() {
    return JSON.stringify({ content: this.content, selection: this.selection });
  }
  restore(memento) {
    const state = JSON.parse(memento);
    this.content = state.content;
    this.selection = state.selection;
  }
}

// Caretaker: 只存取快照，不窥探其内容
class HistoryStack {
  constructor(limit = 50) {
    this.stack = [];
    this.limit = limit;
  }
  push(memento) {
    this.stack.push(memento);
    if (this.stack.length > this.limit) this.stack.shift();
  }
  pop() { return this.stack.pop(); }
}

// 使用
const editor = new Editor();
const history = new HistoryStack();

history.push(editor.createMemento());
editor.type('Hello');
editor.setSelection(0, 5);

// 撤回到快照
editor.restore(history.pop());
```

#### 4.5.2 表单草稿自动保存/恢复

```js
class FormDraft {
  constructor(storageKey) {
    this.storageKey = storageKey;
    this.data = {};
  }
  setData(partial) { Object.assign(this.data, partial); }
  createMemento() { return JSON.stringify(this.data); }
  restore(m) { this.data = JSON.parse(m || '{}'); }
}

class DraftKeeper {
  constructor(originator, key) { this.originator = originator; this.key = key; }
  save() { localStorage.setItem(this.key, this.originator.createMemento()); }
  load() { this.originator.restore(localStorage.getItem(this.key)); }
  clear() { localStorage.removeItem(this.key); }
}

// 使用
const form = new FormDraft('userForm');
const keeper = new DraftKeeper(form, 'draft:userForm');
keeper.load(); // 页面打开时恢复

// 用户输入时定时保存
setInterval(() => keeper.save(), 2000);
```

#### 4.5.3 画布/富文本编辑快照与回滚

```js
class CanvasDoc {
  constructor() { this.layers = []; }
  addLayer(layer) { this.layers.push(layer); }
  createMemento() { return JSON.stringify(this.layers); }
  restore(m) { this.layers = JSON.parse(m || '[]'); }
}

class SnapshotManager {
  constructor(doc) { this.doc = doc; this.undoStack = []; this.redoStack = []; }
  take() { this.undoStack.push(this.doc.createMemento()); this.redoStack.length = 0; }
  undo() { 
    const m = this.undoStack.pop(); 
    if (m) { 
      this.redoStack.push(this.doc.createMemento()); 
      this.doc.restore(m); 
    } }
  redo() { 
    const m = this.redoStack.pop(); 
    if (m) { this.undoStack.push(this.doc.createMemento()); this.doc.restore(m); } }
}
```

#### 4.5.4 乐观更新回滚（请求失败恢复 UI）

```js
async function optimisticToggle(originator, doRequest) {
  const snapshot = originator.createMemento();
  try {
    originator.toggle(); // 立即更新 UI
    await doRequest();   // 请求失败则回滚
  } catch (e) {
    originator.restore(snapshot);
  }
}
```

#### 4.5.5 全局设置/主题切换可恢复

```js
class Settings {
  constructor() { this.theme = 'light'; this.lang = 'zh-CN'; }
  set(p) { Object.assign(this, p); }
  createMemento() { return JSON.stringify({ theme: this.theme, lang: this.lang }); }
  restore(m) { Object.assign(this, JSON.parse(m)); }
}

function withRevert(originator, change) {
  const m = originator.createMemento();
  change();
  return () => originator.restore(m); // 返回撤销函数
}

// 使用
const settings = new Settings();
const revert = withRevert(settings, () => settings.set({ theme: 'dark' }));
// 用户点击“撤销”
revert();
```

#### 4.5.6 多步骤向导/过滤器条件回退

```js
class WizardState {
  constructor() { this.step = 1; this.payload = {}; }
  createMemento() { return JSON.stringify(this); }
  restore(m) { Object.assign(this, JSON.parse(m)); }
}

class WizardHistory {
  constructor(originator) { this.o = originator; this.stack = []; }
  checkpoint() { this.stack.push(this.o.createMemento()); }
  back() { const m = this.stack.pop(); if (m) this.o.restore(m); }
}
```

#### 4.5.7 要点与建议

- 快照要尽量小：仅保存必要状态（或增量差异）
- 保密性：Caretaker 不应解析 Memento，避免泄露内部实现
- 与命令模式配合：命令用于记录“做了什么”，备忘录记录“做完后的状态”
- 存储介质：内存、localStorage、IndexedDB、服务端均可

### 4.6 观察者模式

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

:::tip
观察者模式（发布-订阅）让“被观察者”在状态变化时通知所有订阅者。前端中广泛用于组件通信、事件系统、数据流、可见性/尺寸观察、网络推送等。
:::

#### 4.6.1 轻量级事件总线（发布-订阅）

```js
class EventBus {
  constructor() { this.map = new Map(); }
  on(event, handler) {
    const list = this.map.get(event) || []; 
    list.push(handler); 
    this.map.set(event, list);
    return () => this.off(event, handler);
  }
  off(event, handler) {
    const list = this.map.get(event) || []; 
    this.map.set(event, list.filter(h => h !== handler));
  }
  emit(event, payload) {
    (this.map.get(event) || []).forEach(h => h(payload));
  }
}

// 使用
const bus = new EventBus();
const off = bus.on('login', (user) => console.log('welcome', user));
bus.emit('login', { id: 1 });
off();
```

#### 4.6.2 DOM 事件与自定义事件

```js
// DOM 原生观察者机制
document.addEventListener('click', e => console.log('clicked', e));

// 自定义事件
const el = document.createElement('div');
el.addEventListener('hello', e => console.log('payload', e.detail));
el.dispatchEvent(new CustomEvent('hello', { detail: { a: 1 } }));
```

#### 4.6.3 可见性/尺寸/结构观察

```js
// IntersectionObserver：元素可见性（懒加载/曝光埋点/无限滚动）
const io = new IntersectionObserver(entries => {
  entries.forEach(en => { if (en.isIntersecting) console.log('exposed', en.target); });
});
io.observe(document.querySelector('#card'));

// ResizeObserver：尺寸变化
const ro = new ResizeObserver(entries => entries.forEach(en => console.log(en.contentRect)));
ro.observe(document.querySelector('#panel'));

// MutationObserver：DOM 结构变动
const mo = new MutationObserver(ms => console.log('mutations', ms));
mo.observe(document.body, { childList: true, subtree: true });
```

#### 4.6.4 数据流与响应式（RxJS / 自实现）

```js
// 极简 Observable
class Observable {
  constructor(subscribe) { this._subscribe = subscribe; }
  subscribe(observer) { return this._subscribe(observer); }
  map(fn) { return new Observable(obs => this.subscribe({ next: v => obs.next(fn(v)) })); }
}

const timer = new Observable(obs => {
  let i = 0; const id = setInterval(() => obs.next(i++), 1000);
  return { unsubscribe: () => clearInterval(id) };
});

const sub = timer.map(x => x * 2).subscribe({ next: v => console.log(v) });
setTimeout(() => sub.unsubscribe(), 3500);
```

#### 4.6.5 状态管理订阅（Store.subscribe）

```js
// 简版 Store，支持订阅状态变化
class Store {
  constructor(initial) { this.state = initial; this.listeners = new Set(); }
  getState() { return this.state; }
  setState(patch) { this.state = { ...this.state, ...patch }; this.listeners.forEach(l => l(this.state)); }
  subscribe(fn) { this.listeners.add(fn); return () => this.listeners.delete(fn); }
}

const store = new Store({ count: 0 });
const unsub = store.subscribe(s => console.log('state', s));
store.setState({ count: 1 });
unsub();
```

#### 4.6.6 跨标签页/线程通知

```js
// BroadcastChannel：多标签页同步
const channel = new BroadcastChannel('app');
channel.onmessage = e => console.log('from tab', e.data);
channel.postMessage({ type: 'PING' });

// postMessage + message 事件：主线程与 Worker
const worker = new Worker('/w.js');
worker.onmessage = e => console.log('from worker', e.data);
worker.postMessage({ cmd: 'start' });
```

#### 4.6.7 网络推送/实时通信（WebSocket/SSE）

```js
// WebSocket：服务端主动推送 -> 前端观察者收到更新
const ws = new WebSocket('wss://example.com');
ws.onmessage = e => console.log('server says', e.data);
```

### 4.7 状态模式

能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

:::tip
状态模式通过把“状态”抽象为对象，避免在一个类中充斥大量 if/else 或 switch 分支，并允许在运行时通过切换状态对象来改变行为。适合处理异步流程编排、复杂表单/多步骤向导、UI 控件不同状态、网络请求状态机等。
:::

#### 4.7.1 异步流程状态机（加载/成功/失败/重试）

```js
class State {
  enter(ctx) {}
  exit(ctx) {}
  async next(ctx, event) {}
}

class Idle extends State {
  async next(ctx, event) {
    if (event.type === 'FETCH') {
      ctx.setState(new Loading());
      try {
        ctx.data = await ctx.fetcher();
        ctx.setState(new Success());
      } catch (e) {
        ctx.error = e;
        ctx.setState(new Failure());
      }
    }
  }
}

class Loading extends State {}
class Success extends State {
  async next(ctx, event) {
    if (event.type === 'REFRESH') ctx.setState(new Idle());
  }
}
class Failure extends State {
  async next(ctx, event) {
    if (event.type === 'RETRY') ctx.setState(new Idle());
  }
}

class RequestMachine {
  constructor(fetcher) {
    this.state = new Idle();
    this.fetcher = fetcher;
    this.data = null;
    this.error = null;
  }
  setState(s) { this.state.exit?.(this); this.state = s; this.state.enter?.(this); }
  send(event) { return this.state.next(this, event); }
}

// 使用
const machine = new RequestMachine(async () => (await fetch('/api')).json());
machine.send({ type: 'FETCH' });
```

#### 4.7.2 UI 控件状态（按钮：默认/加载中/禁用）

```js
class ButtonState { apply(btn) {} }
class BtnDefault extends ButtonState { apply(btn) { btn.text = '提交'; btn.disabled = false; btn.loading = false; } }
class BtnLoading extends ButtonState { apply(btn) { btn.text = '提交中...'; btn.disabled = true; btn.loading = true; } }
class BtnDisabled extends ButtonState { apply(btn) { btn.text = '不可用'; btn.disabled = true; btn.loading = false; } }

class StatefulButton {
  constructor() { this.text='提交'; this.disabled=false; this.loading=false; this.state = new BtnDefault(); }
  setState(s) { this.state = s; this.state.apply(this); }
}

const btn = new StatefulButton();
btn.setState(new BtnLoading());
```

#### 4.7.3 表单/向导状态（步骤切换、校验、可见性）

```js
class StepState {
  canNext(ctx) { return true; }
  canPrev(ctx) { return true; }
  beforeEnter(ctx) {}
}
class Step1 extends StepState { canNext(ctx) { return !!ctx.data.a; } }
class Step2 extends StepState { canNext(ctx) { return !!ctx.data.b; } }
class Step3 extends StepState {}

class Wizard {
  constructor() { this.steps=[new Step1(), new Step2(), new Step3()]; this.index=0; this.data={}; }
  get state() { return this.steps[this.index]; }
  next() { if (this.state.canNext(this)) this.index = Math.min(this.index+1, this.steps.length-1); }
  prev() { if (this.state.canPrev(this)) this.index = Math.max(this.index-1, 0); }
}
```

#### 4.7.4 播放器状态（播放/暂停/停止）

```js
class PlayerState { play(p){} pause(p){} stop(p){} }
class Stopped extends PlayerState {
  play(p) { p.setState(new Playing()); }
}
class Playing extends PlayerState {
  pause(p) { p.setState(new Paused()); }
  stop(p) { p.setState(new Stopped()); }
}
class Paused extends PlayerState {
  play(p) { p.setState(new Playing()); }
  stop(p) { p.setState(new Stopped()); }
}

class Player {
  constructor() { this.state = new Stopped(); }
  setState(s) { this.state = s; }
  play() { this.state.play(this); }
  pause() { this.state.pause(this); }
  stop() { this.state.stop(this); }
}
```

#### 4.7.5 请求/会话状态（未登录/已登录/过期）

```js
class AuthState { enter(ctx){} next(ctx,e){} }
class Guest extends AuthState {
  next(ctx, e) { if (e.type==='LOGIN_SUCCESS') ctx.setState(new LoggedIn()); }
}
class LoggedIn extends AuthState {
  next(ctx, e) { if (e.type==='LOGOUT' || e.type==='TOKEN_EXPIRED') ctx.setState(new Guest()); }
}

class AuthMachine {
  constructor(){ this.state=new Guest(); }
  setState(s){ this.state=s; }
  send(e){ this.state.next(this,e); }
}
```

### 4.8 策略模式

能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

:::tip
策略模式将可替换的算法/行为抽象为同一接口，运行时可按需选择/切换。适合表单校验、排序/搜索、缓存淘汰、价格/税率计算、重试退避、渲染/格式化、支付/登录渠道等。
:::

#### 4.8.1 表单校验策略

```js
class ValidatorStrategy { 
  validate(value) { return true; } 
}
class Required extends ValidatorStrategy { 
  validate(v) { return v != null && String(v).trim() !== ''; } 
}
class Email extends ValidatorStrategy { 
  validate(v) { return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(v); } 
}
class MinLength extends ValidatorStrategy { 
  constructor(n){ super(); this.n=n; } 
  validate(v){ return String(v||'').length >= this.n; } }

class FieldValidator {
  constructor() { this.strategies = []; }
  use(s) { this.strategies.push(s); return this; }
  check(value) { return this.strategies.every(s => s.validate(value)); }
}

const username = new FieldValidator().use(new Required()).use(new MinLength(3));
const email = new FieldValidator().use(new Email());
```

#### 4.8.2 排序/搜索策略（可运行时切换）

```js
const sorters = {
  byName: (a,b) => a.name.localeCompare(b.name),
  byTimeDesc: (a,b) => b.time - a.time,
  byScore: (a,b) => b.score - a.score,
};

function sortItems(items, strategyKey) { return [...items].sort(sorters[strategyKey]); }
```

#### 4.8.3 缓存淘汰策略（LRU / LFU / FIFO）

```js
class Evictor { onGet(key){} onSet(key){} evict(cache){} }
class FIFO extends Evictor {
  constructor(){ super(); this.queue=[]; }
  onSet(key){ this.queue.push(key); }
  evict(cache){ 
    const k=this.queue.shift(); 
    if(k!==undefined) cache.delete(k); 
  }
}
class LRU extends Evictor {
  constructor(){ super(); this.list=new Map(); }
  onGet(key){ 
    if(!this.list.has(key)) return; 
    const v=this.list.get(key); 
    this.list.delete(key); 
    this.list.set(key,v); }
  onSet(key){ this.list.set(key, Date.now()); }
  evict(cache){ 
    const k=this.list.keys().next().value; 
    this.list.delete(k); 
    cache.delete(k);
  }
}

class Cache {
  constructor(limit=100, evictor=new LRU()) { 
    this.map=new Map(); 
    this.limit=limit; 
    this.evictor=evictor; 
  }
  get(k){ 
    const v=this.map.get(k); 
    if(v!==undefined) this.evictor.onGet(k); 
    return v; 
  }
  set(k,v){ 
    if(this.map.size>=this.limit) this.evictor.evict(this.map); 
    this.map.set(k,v); 
    this.evictor.onSet(k); 
  }
}
```

#### 4.8.4 价格/税率/折扣策略

```js
const pricingStrategies = {
  normal: (p) => p,
  discount10: (p) => p * 0.9,
  vip: (p) => p * 0.85,
  regionTax: (p, region) => region==='EU' ? p*1.2 : p,
};

function calcPrice(base, strategyKey, ctx){
  const fn = pricingStrategies[strategyKey] || pricingStrategies.normal;
  return fn(base, ctx);
}
```

#### 4.8.5 重试/退避策略（网络请求）

```js
const backoff = {
  none: (i)=>0,
  linear: (i)=> i*300,
  exponential: (i)=> Math.min(1000 * 2**i, 8000),
};

async function retry(requestFn, times=3, strat='exponential'){
  for(let i=0;i<=times;i++){
    try { return await requestFn(); }
    catch(err){ if(i===times) throw err; await new Promise(r=>setTimeout(r, backoff[strat](i))); }
  }
}
```

#### 4.8.6 渲染/格式化策略（i18n、数值/日期）

```js
const formatters = {
  currency: (n, locale='zh-CN', currency='CNY') => new Intl.NumberFormat(locale, { style:'currency', currency }).format(n),
  date: (d, locale='zh-CN') => new Intl.DateTimeFormat(locale).format(new Date(d)),
};
```

#### 4.8.7 支付/登录渠道策略

```js
const payments = {
  alipay: (order)=>{/* ... */},
  wechat: (order)=>{/* ... */},
  stripe: async (order)=>{/* ... */},
};

async function pay(order, channel){ return payments[channel](order); }
```

### 4.9 模板方法模式

在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。

:::tip
模板方法通过在基类中固定流程骨架，把可变步骤留给子类实现，既复用流程又允许差异化实现。常用于：请求流程（鉴权/日志/异常）、表单提交流程、构建/打包流水线、数据导出/导入、组件渲染前置/后置钩子等。
:::

#### 4.9.1 请求流程的模板（鉴权 -> 业务 -> 异常处理 -> 日志）

```js
class RequestTemplate {
  async handle(ctx) {
    try {
      await this.before(ctx);       // 鉴权/限流/参数校验
      const result = await this.process(ctx); // 由子类实现
      await this.after(ctx, result); // 记录日志/埋点
      return result;
    } catch (e) {
      return this.onError(ctx, e);  // 同一异常处理
    }
  }
  async before(ctx) {}
  async process(ctx) { throw new Error('process not implemented'); }
  async after(ctx, result) {}
  onError(ctx, e) { console.error(e); return { ok: false, message: e.message }; }
}

class CreateOrderHandler extends RequestTemplate {
  async before(ctx){ /* 校验 token/参数 */ }
  async process(ctx){ /* 业务创建订单 */ return { ok: true, id: 1 }; }
  async after(ctx, res){ /* 订单日志 */ }
}

// 使用
const handler = new CreateOrderHandler();
handler.handle({ headers:{}, body:{} });
```

#### 4.9.2 表单提交模板（校验 -> 转换 -> 提交 -> 回显）

```js
class SubmitTemplate {
  async submit(form){
    const valid = await this.validate(form);
    if(!valid) return { ok:false };
    const payload = this.transform(form);
    const res = await this.post(payload);
    await this.feedback(res);
    return res;
  }
  async validate(form){ return true; }
  transform(form){ return form; }
  async post(payload){ throw new Error('post not implemented'); }
  async feedback(res){}
}
```

#### 4.9.3 构建/打包任务模板（前置 -> 构建 -> 后置）

```js
class BuildTask {
  async run(){
    await this.pre();
    await this.build();
    await this.post();
  }
  async pre(){}
  async build(){ throw new Error('build not implemented'); }
  async post(){}
}
```

#### 4.9.4 数据导出模板（查询 -> 转换 -> 输出）

```js
class ExportTemplate {
  async execute(params){
    const rows = await this.query(params);
    const data = this.transform(rows);
    return this.output(data);
  }
  async query(params){ throw new Error('query not implemented'); }
  transform(rows){ return rows; }
  output(data){ return new Blob([JSON.stringify(data)]); }
}
```

#### 4.9.5 组件渲染模板（beforeRender/afterRender 钩子）

```js
class ComponentTemplate {
  render(props){
    this.beforeRender?.(props);
    const vnode = this.doRender(props); // 子类实现
    this.afterRender?.(props, vnode);
    return vnode;
  }
  doRender(props){ throw new Error('doRender not implemented'); }
}
```

### 4.10 访问者模式

能将算法与其所作用的对象隔离开来。

:::tip
访问者模式将作用于对象结构的操作“分离”为访问者，方便在不修改对象结构的情况下，新增跨越多类/多节点的操作。前端常用于 AST/虚拟 DOM/表单模型/权限树等结构上的批量操作、校验、收集与转换。
:::

#### 4.10.1 AST/语法树遍历与改写（Babel/ESLint 思想）

```js
// 简化的节点与访问者接口
class Node { accept(visitor) { visitor.visit(this); } }
class Program extends Node { 
  constructor(body=[]) { 
    super(); 
    this.type='Program'; 
    this.body = body; 
  } 
}
class CallExpr extends Node { 
  constructor(name,args=[]) { 
    super(); 
    this.type='CallExpression'; 
    this.name=name; 
    this.args=args; 
  } }

class Visitor {
  visit(node) {
    const fn = this[`visit_${node.type}`] || this.generic;
    return fn.call(this, node);
  }
  generic(node) { /* 默认遍历 */ 
  if (node.body) node.body.forEach(n => n.accept(this)); 
  if (node.args) node.args.forEach(n => n.accept(this)); }
}

// 访问者：收集所有函数调用名
class CollectCalls extends Visitor {
  constructor(){ 
    super(); 
    this.calls = new Set();
  }
  visit_CallExpression(node){ 
    this.calls.add(node.name); 
    this.generic(node); 
  }
}

const ast = new Program([ new CallExpr('fetch'), new CallExpr('log') ]);
const v = new CollectCalls();
ast.accept(v);
console.log([...v.calls]);
```

#### 4.10.2 虚拟 DOM 树批量处理（统计/转换/批注）

```js
class VNode { 
  constructor(type, props={}, children=[]) { 
    this.type=type; 
    this.props=props; 
    this.children=children; 
  }
  accept(visitor){ visitor.visit(this); } }

class VVisitor {
  visit(node){ 
    this.before?.(node); 
    node.children?.forEach(c => c.accept(this)); 
    this.after?.(node); 
  }
}

// 统计某类节点数量
class CountByType extends VVisitor {
  constructor(target){ super(); this.target=target; this.count=0; }
  before(node){ if(node.type===this.target) this.count++; }
}
```

#### 4.10.3 表单/配置模型的批量校验与收集

```js
class Field { 
  constructor(name, rules=[]) {
     this.name=name; 
     this.rules=rules; 
  } 
  accept(v){ v.visitField?.(this); } 
}
class Group { 
  constructor(children=[]) { 
    this.children=children; 
  } 
  accept(v){ 
    v.visitGroup?.(this); 
    this.children.forEach(c=>c.accept(v)); 
  } 
}

class ValidateVisitor {
  constructor(errors=[]) { this.errors=errors; }
  visitField(f){ 
    for(const r of f.rules){ 
      const res=r(); 
      if(res!==true) this.errors.push({ field:f.name, message:res }); 
    } 
  }
}
```

#### 4.10.4 权限树/路由树的收集与改写

```js
class RouteNode { 
  constructor(path, meta={}, children=[]) {
    this.path=path; 
    this.meta=meta; 
    this.children=children;
 }
  accept(v){ 
    v.visitRoute?.(this); 
    this.children.forEach(c=>c.accept(v)); 
  } }

class CollectAuthRoutes {
  constructor(user){ this.user=user; this.allowed=[]; }
  visitRoute(n){ 
    if(!n.meta.role || n.meta.role.includes(this.user.role)) this.allowed.push(n.path); 
  }
}
```
