# 设计模式之行为型

## 4. 行为型模式

:::tip
行为模式负责对象间的高效沟通和职责委派。
:::

### 4.1 责任链模式

:::tip
允许将请求沿着处理者链进行发送。 收到请求后， 每个处理者均可对请求进行处理， 或将其传递给链上的下个处理者。

前端开发中，责任链模式（Chain of Responsibility Pattern）的应用场景主要集中在请求处理流程、事件处理、中间件机制等场景。责任链模式的核心思想是将请求的发送者和接收者解耦，让多个对象都有机会处理请求，直到有一个对象处理它为止。

优点：
降低耦合度，增加灵活性
动态组合处理流程
易于扩展和维护
:::

#### 4.1.1 表单验证链

场景说明：
表单提交时需要经过多个验证步骤（如必填验证、格式验证、长度验证、业务验证等），每个验证器都可以处理请求或传递给下一个验证器。
示例：

```js
class Validator {
  constructor() {
    this.next = null;
  }
  setNext(validator) {
    this.next = validator;
    return validator;
  }
  validate(data) {
    if (this.next) {
      return this.next.validate(data);
    }
    return true;
  }
}

class RequiredValidator extends Validator {
  validate(data) {
    if (!data.value) {
      return { error: '必填项不能为空' };
    }
    return super.validate(data);
  }
}

class EmailValidator extends Validator {
  validate(data) {
    if (data.type === 'email' && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(data.value)) {
      return { error: '邮箱格式不正确' };
    }
    return super.validate(data);
  }
}

// 使用
const chain = new RequiredValidator();
chain.setNext(new EmailValidator());
const result = chain.validate({ value: 'test', type: 'email' });
```

#### 4.1.2 中间件机制（Express.js、Koa.js）

场景说明：
Node.js 框架中的中间件机制就是责任链模式的典型应用。每个中间件都可以处理请求，或者调用 next() 传递给下一个中间件。
示例：

```js
// Express.js 中间件
app.use((req, res, next) => {
  console.log('中间件1');
  next(); // 传递给下一个中间件
});

app.use((req, res, next) => {
  console.log('中间件2');
  next();
});

app.get('/', (req, res) => {
  res.send('Hello');
});
```

#### 4.1.3 事件处理链

场景说明：
DOM 事件处理中的事件冒泡机制，事件会沿着 DOM 树向上传播，每个节点都有机会处理事件。
示例：

```js
// 事件处理链
document.addEventListener('click', (e) => {
  console.log('Document 处理点击事件');
  // 可以选择阻止事件继续传播
  // e.stopPropagation();
});

document.body.addEventListener('click', (e) => {
  console.log('Body 处理点击事件');
});
```

### 4.2 命令模式

可将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。

### 4.3 迭代器模式

能在不暴露集合底层表现形式 （列表、 栈和树等） 的情况下遍历集合中所有的元素。

### 4.4 中介者模式

减少对象之间混乱无序的依赖关系。 该模式会限制对象之间的直接交互， 迫使它们通过一个中介者对象进行合作。

### 4.5 备忘录模式

允许在不暴露对象实现细节的情况下保存和恢复对象之前的状态。

### 4.6 观察者模式

允许你定义一种订阅机制， 可在对象事件发生时通知多个 “观察” 该对象的其他对象。

### 4.7 状态模式

能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

### 4.8 策略模式

能让你定义一系列算法， 并将每种算法分别放入独立的类中， 以使算法的对象能够相互替换。

### 4.9 模板方法模式

在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。

### 4.10 访问者模式

能将算法与其所作用的对象隔离开来。
