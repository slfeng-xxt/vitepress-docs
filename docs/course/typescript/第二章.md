# 第二章

## 6.对象类型

对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。

```ts
// 属性类型以分号结尾
type User = {
  readonly x: number; // 只读属性
  y?: number; // ? 可选属性写法一
  //   y: numnber | undefined; // 可选属性写法二
  name: string;
  add(x: number, y: number): number;
  // 或者写成
  // add: (x:number, y:number) => number;
};

type Name = User["name"]; // string

// 属性类型以逗号结尾
type MyObj = {
  x: number;
  y: number;
};
// 最后一个属性后面，可以写分号或逗号，也可以不写

// 除了type命令可以为对象类型声明一个别名，TypeScript 还提供了interface命令，可以把对象类型提炼为一个接口。
// 写法二
interface MyObj {
  x: number;
  y: number;
}
```

规则：

- 一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。
- 也不能删除类型声明中存在的属性
- 修改属性值是可以的。
- TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。
- 读取可选属性之前，必须检查一下是否为 undefined。
- 对象后面加了只读断言 as const，就变成只读对象了，不能修改属性了。as const 属于 TypeScript 的类型推断,如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。

```ts
// ES2020 引入了一个新的 Null 判断运算符??  它的行为类似||，但是只有运算符左侧的值为null或undefined时，才会返回右侧的值。

// 写法一
let firstName = user.firstName === undefined ? "Foo" : user.firstName;
let lastName = user.lastName === undefined ? "Bar" : user.lastName;

// 写法二
let firstName = user.firstName ?? "Foo";
let lastName = user.lastName ?? "Bar";
```

### 属性名的索引类型

如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。
属性索引共有 string、number 和 symbol 三种类型。

```ts
type MyObj = {
  [property: string]: string;
};

const obj: MyObj = {
  foo: "a",
  bar: "b",
  baz: "c",
};
```

对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名

```ts
type MyType = {
  [x: number]: boolean; // 报错
  [x: string]: string;
};
```

### 解构赋值

注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。

```ts
// 正确写法
const {
  id,
  name,
  price,
}: {
  id: string;
  name: string;
  price: number;
} = product;

// 错误写法
function draw({ shape: Shape, xPos: number = 100, yPos: number = 100 }) {
  let myShape = shape; // 报错： 函数体内不存在变量shape，而是属性shape的值被赋值给了变量Shape。
  let x = xPos; // 报错
}
```

### 结构类型原则

只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structual typing）。

- 根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。
- TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。

### 严格字面量检查

如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）

- 规避严格字面量检查，可以使用中间变量。

```ts
let myOptions = {
  title: "ts",
  content: "xxxxx",
};

const Obj: Options = myOptions;
```

### 最小可选属性规则

如果一个对象的所有属性都是可选的，会触发最小可选属性规则。

- 为了避免这种情况，TypeScript 添加了最小可选属性规则，规定这时属于 Options 类型的对象，必须至少存在一个可选属性，不能所有可选属性都不存在

### 空对象

空对象是 TypeScript 的一种特殊值，也是一种特殊类型。

- 空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象 Object.prototype 的属性。

```ts
const obj: {} = {};
obj.a = 123; // 报错
obj.toString(); // 正确
```

## 7.interface

interface 是对象的模板，可以看作是一种类型约定，中文译为“接口”。使用了某个模板的对象，就拥有了指定的类型结构。

### 对象的方法写法

```ts
// 写法一
interface A {
  f(x: boolean): string;
  f(x: string, y: string): string; // 重载
}

// 写法二
interface B {
  f: (x: boolean) => string;
}

// 写法三
interface C {
  f: { (x: boolean): string };
}
```

- interface 里面的函数重载，不需要给出实现。但是，由于对象内部定义方法时，无法使用函数重载的语法，所以需要额外在对象外部给出函数方法的实现

### 函数

interface 也可以用来声明独立的函数。

```ts
interface Add {
  (x: number, y: number): number;
}

const myAdd: Add = (x, y) => x + y;
```

### 构造函数表示

interface 内部可以使用 new 关键字，表示构造函数。

```ts
interface ErrorConstructor {
  new (message?: string): Error;
}
```

### 继承（主要作用是添加属性）

- 多重接口继承，实际上相当于多个父接口的合并。
- 多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。
- 子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。
- interface 可以继承 type 命令定义的对象类型。
- interface 还可以继承 class，即继承该类的所有成员。

```ts
interface Shape {
  name: string;
}

type Animal = {
  spin: boolean;
};

class Content {
  title: string = "";
  getTitle(): string {
    return this.title;
  }
}

interface Circle extends Shape, Animal, Content {
  radius: number;
  name: number; // 报错: 子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错。
}
```

## 8.interface 与 type 的异同

相同点：

- interface 命令与 type 命令作用类似，都可以表示对象类型。

不同点：

- type 能够表示非对象类型，而 interface 只能表示对象类型（包括数组、函数等）。
- interface 可以继承其他类型，type 不支持继承。type 定义的对象类型如果想要添加属性，只能使用&运算符，重新定义一个类型。
- 同名 interface 会自动合并，同名 type 则会报错。也就是说，TypeScript 不允许使用 type 多次定义同一个类型。
- interface 不能包含属性映射（mapping），type 可以
- this 关键字只能用于 interface。
- type 可以扩展原始数据类型，interface 不行。
- interface 无法表达某些复杂类型（比如交叉类型和联合类型），但是 type 可以。

```ts
type Animal = {
  name: string;
};

type Bear = Animal & {
  honey: boolean;
};

interface Animal {
  name: string;
}

interface Bear extends Animal {
  honey: boolean;
}

interface Point {
  x: number;
  y: number;
}

// 映射正确
type PointCopy1 = {
  [Key in keyof Point]: Point[Key]; // 映射
};

// 报错
interface PointCopy2 {
  [Key in keyof Point]: Point[Key];
};

// 正确
type MyStr = string & {
  type: "new";
};
```

总结：

- 如果有复杂的类型运算，那么没有其他选择只能使用 type；一般情况下，interface 灵活性比较高，便于扩充类型或自动合并，建议优先使用。

补充：

- class 命令也有类似作用，通过定义一个类，同时定义一个对象类型。但是，它会创造一个值，编译后依然存在。如果只是单纯想要一个类型，应该使用 type 或 interface。

## 9.class

类（class）是面向对象编程的基本构件，封装了属性和方法；
TypeScript 的类本身就是一种类型，但是它代表该类的实例类型，而不是 class 的自身类型。

```txt
凡我所失，皆非我所有；凡我所求，皆受其所困；万物皆为我所用，而非我所属；君子使物，不为物使；大道至简，无欲则刚，无为则无所不为
```

- constructor() 构造方法不能声明返回值类型，否则报错，因为它总是返回实例对象。

### TypeScript 对 class 存取器(get/set)有以下规则

- 如果某个属性只有 get 方法，没有 set 方法，那么该属性自动成为只读属性。
- set 方法的参数类型，必须兼容 get 方法的返回值类型，否则报错。
- get 方法与 set 方法的可访问性必须一致，要么都为公开方法，要么都为私有方法。

### implements 关键字

- interface 接口或 type 别名，可以用对象的形式，为 class 指定一组检查条件。然后，类使用 implements 关键字，表示当前类满足这些外部类型条件的限制。
- interface 只是指定检查条件，如果不满足这些条件就会报错。它并不能代替 class 自身的类型声明。
- TypeScript 不允许两个同名的类，但是如果一个类和一个接口同名，那么接口会被合并进类。

### 类的实例类型

对于引用实例对象的变量来说，既可以声明类型为 Class，也可以声明类型为 Interface，因为两者都代表实例对象的类型。

```ts
interface MotorVehicle {}

class Car implements MotorVehicle {}

// 写法一
const c1: Car = new Car();
// 写法二
const c2: MotorVehicle = new Car();
```

注意：

- 作为类型使用时，类名只能表示实例的类型，不能表示类的自身类型。

### 获得一个类的自身类型

```ts
// 写法一： 要获得一个类的自身类型，一个简便的方法就是使用 typeof 运算符。
function createPoint(PointClass: typeof Point, x: number, y: number): Point {
  return new PointClass(x, y);
}
// JavaScript 语言中，类只是构造函数的一种语法糖，本质上是构造函数的另一种写法。所以，类的自身类型可以写成构造函数的形式。
// 写法二：new (x: number, y: number) => Point
function createPoint(
  PointClass: new (x: number, y: number) => Point,
  x: number,
  y: number
): Point {
  return new PointClass(x, y);
}
// 写法三：构造函数也可以写成对象形式 { new (x: number, y: number): Point;  }
function createPoint(
  PointClass: {
    new (x: number, y: number): Point;
  },
  x: number,
  y: number
): Point {
  return new PointClass(x, y);
}
// 写法四： interface
interface PointConstructor {
  new (x: number, y: number): Point;
}

function createPoint(
  PointClass: PointConstructor,
  x: number,
  y: number
): Point {
  return new PointClass(x, y);
}
```

```txt
人生似书卷，风吹哪页读哪页
```

### 类的继承（extends）

类（这里又称“子类”）可以使用 extends 关键字继承另一个类（这里又称“基类”）的所有属性和方法。【类是构造函数语法糖】

```txt
ES6引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。constructor()方法，这就是构造方法，而this关键字则代表实例对象。

类的所有方法都定义在类的prototype属性上面，方法前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。使用的时候，类必须使用new调用跟构造函数的用法完全一致。
```

```ts
class A {
  greet() {
    console.log("Hello, world!");
  }
}

class B extends A {
  // 子类可以覆盖基类的同名方法。
  greet(name?: string) {
    if (name === undefined) {
      super.greet(); // 调用基类A的greet()方法
    } else {
      console.log(`Hello, ${name}`);
    }
  }
}

const b = new B();
b.greet(); // "Hello, world!"
b.greet("Tom"); // "Hello, Tom"
```

注意：

- 如果基类包括保护成员（protected 修饰符），子类可以将该成员的可访问性设置为公开（public 修饰符），也可以保持保护成员不变，但是不能改用私有成员（private 修饰符）
- extends 关键字后面不一定是类名，可以是一个表达式，只要它的类型是构造函数就可以了。（类的本质）

### 可访问性修饰符

- public 省略不写的
- private 只能用在当前类的内部，类的实例和子类都不能使用该成员。（子类不能定义父类私有成员的同名成员。如果在类的内部，当前类的实例可以获取私有成员。）
- protected 该成员是保护成员，只能在类的内部使用该成员，实例无法使用该成员，但是子类内部可以使用。(子类不仅可以拿到父类的保护成员，还可以定义同名成员。)

```txt
严格地说，private定义的私有成员，并不是真正意义的私有成员。一方面，编译成 JavaScript 后，private关键字就被剥离了，这时外部访问该成员就不会报错。
另一方面，由于前一个原因，TypeScript 对于访问private成员没有严格禁止，使用方括号写法（[]）或者in运算符，实例对象就能访问该成员。

由于private存在这些问题，加上它是 ES6 标准发布前出台的，而 ES6 引入了自己的私有成员写法#propName。因此建议不使用private，改用 ES6 的写法，获得真正意义的私有成员。
```

```ts
class A {
  private x = 1;
  #y = 2;
}
const a = new A();
console.log(a.x); // Property 'x' is private and only accessible within class 'A'.
console.log(a["x"]); // 1
console.log(a["y"]); // 报错
```

### 实例属性的简写形式

```ts
class Point {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    this.x = x;
    this.y = y;
  }
}
// 简写
class Point {
  constructor(public x: number, public y: number) {} // 这里的public不能省略,和其他修饰符一样写出来
}

const p = new Point(1, 2);
console.log(p.x);
console.log(p.y);
```

### 静态成员

类的内部可以使用 static 关键字，定义静态成员。（只能通过【类本身】使用的成员，不能通过【实例对象】使用。）

```ts
class MyClass {
  static x = 0;
  static printX() {
    console.log(MyClass.x);
  }
}

MyClass.x; // 0
MyClass.printX(); // 0
```

### 抽象类，抽象成员

TypeScript 允许在类的定义前面，加上关键字 abstract，表示该类不能被实例化，只能当作其他类的模板。这种类就叫做“抽象类”（abastract class）。

抽象类只能当作基类使用，用来在它的基础上定义子类。

#### 抽象成员

- 抽象类的内部可以有已经实现好的属性和方法，也可以有还未实现的属性和方法。后者就叫做“抽象成员”（abstract member），即属性名和方法名有 abstract 关键字，表示该方法需要子类实现。如果子类没有实现抽象成员，就会报错。
- 如果抽象类的属性前面加上 abstract，就表明子类必须给出该方法的实现。

注意

- 抽象成员只能存在于抽象类，不能存在于普通类。
- 抽象成员不能有具体实现的代码。也就是说，已经实现好的成员前面不能加 abstract 关键字。
- 抽象成员前也不能有 private 修饰符，否则无法在子类中实现该成员。
- 一个子类最多只能继承一个抽象类。

总结

抽象类的作用是，确保各种相关的子类都拥有跟基类相同的接口，可以看作是模板。其中的抽象成员都是必须由子类实现的成员，非抽象成员则表示基类已经实现的、由所有子类共享的成员。

### this

this 关键字，它表示该方法当前所在的对象。

- 在类的内部，this 本身也可以当作类型使用，表示当前类的实例对象。

```ts
class Box {
  contents: string = "";
  static a: this; // 报错 this类型不允许应用于静态成员。

  set(value: string): this {
    this.contents = value;
    return this;
  }
}
```

## 10.泛型

“泛型”（generics）反映【参数】与【返回值】之间的类型关系。新增一个传入参数的入口（类型相关的参数），即类型参数 `<T>` 、`<T, U>`；用来表达类型逻辑，与函数普通的形参类似。

```ts
function getFirst<T>(arr: T[]): T {
  return arr[0];
}

getFirst<number>([1, 2, 3]);
```

- 函数 getFirst()的函数名后面尖括号的部分`<T>`，就是【类型参数】，参数要放在一对尖括号（`<>`）里面。本例只有一个类型参数 T，可以将其理解为类型声明需要的变量，需要在调用时传入具体的参数类型。
- 函数 getFirst()的参数类型是 T[]，返回值类型是 T，就清楚地表示了两者之间的关系。比如，输入的参数类型是 number[]，那么 T 的值就是 number，因此返回值类型也是 number。

### 写法

泛型主要用在四个场合：函数、接口、类和别名。

```ts
// 1. 函数
function id<T>(arg: T): T {
  return arg;
}
let myId: <T>(arg: T) => T = id;
let youId: { <T>(arg: T): T } = id;

// 2. 接口
interface Box<T> {
  content: T;
}
let box: Box<string>;
interface Fn {
  <T>(arg: T): T;
}
let myId: Fn = id;

// 3. 类
class A<T> {
  x: T;
}
class B extends A<number> {}
const b = new B();
b.x = 1;
b.x = "2"; // 报错

// 4. 别名 JavaScript 的类本质上是一个构造函数，因此也可以把泛型类写成构造函数。
type MyClass<T> = new (...args: any[]) => T;
type Nullable<T> = T | undefined | null;
type Container<T> = { value: T };
```

注意

- 泛型类描述的是类的实例，不包括静态属性和静态方法，因为这两者定义在类的本身。因此，它们不能引用类型参数

```ts
class C<T> {
  static data: T; // 报错
  constructor(public value: T) {}
}
```

### 类型参数的约束条件

```ts
// 类型参数 Type 有一个隐藏的约束条件：它必须存在length属性。如果不满足这个条件，就会报错。
function comp<Type>(a: Type, b: Type) {
  if (a.length >= b.length) {
    return a;
  }
  return b;
}
// TypeScript 提供了一种语法,允许在类型参数上面写明约束条件；<TypeParameter extents ConstraintType>

function comp <T extends { length: number }>(a: T, b: T) {
  if (a.length >= b.length) {
    return a;
  }
  return b;
}
```

- TypeParameter 类型参数
- extends 是关键字
- ConstraintType 表示类型参数要满足的条件，即类型参数应该是 ConstraintType 的子类型

注意：

- 尽量少用泛型。
- 类型参数越少越好。
- 类型参数需要出现两次。
- 泛型可以嵌套。
