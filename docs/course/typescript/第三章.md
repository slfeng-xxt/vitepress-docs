# 第三章

## 11.Enum 类型

TypeScript 就设计了 Enum 结构，用来将相关常量放在一个容器里面，方便使用。它既是一种类型，也是一个值

:::tip
绝大多数 TypeScript 语法都是类型语法，编译后会全部去除，但是 Enum 结构是一个值，编译后会变成 JavaScript 对象，留在代码中。

由于 TypeScript 的定位是 JavaScript 语言的类型增强，所以官方建议谨慎使用 Enum 结构，因为它不仅仅是类型，还会为编译后的代码加入一个对象。

Enum 作为类型有一个缺点，就是输入任何数值都不报错。
:::

```ts
enum Color {
  Red, // 0
  Green, // 1
  Blue, // 2
}
// Enum 结构本身也是一种类型，它的每个成员都是该类型的一个值。
// type Color = 0 | 1 | 2;
let c: Color = Color.Green; // 1
let c: number = Color.Green; // 1
```

- Enum 结构可以被对象的as const断言替代。使用了as const断言，作用就是使得它的属性无法修改
- 除了数值和字符串，Enum 成员不允许使用其他值（比如 Symbol 值）。
- keyof 运算符可以取出 Enum 结构的所有成员名，作为联合类型返回。

```ts
enum MyEnum {
  A = "a",
  B = "b",
}

// 'A'|'B'
type Foo = keyof typeof MyEnum;
```

- 数值 Enum 存在反向映射，即可以通过成员值获得成员名。

```ts
enum MyEnum {
  A = 1,
  B = 2,
}
console.log(MyEnum[2]); // B
```

## 12.类型断言

:::tip
允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。

类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。
:::

```ts
type T = "a" | "b" | "c";

let foo = "a";
let bar: T = foo; // ❎ Type 'string' is not assignable to type 'T'.
let bar: T = foo as T; // ✅
```

### 语法

```ts
// 尖括号语法
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;

// 推荐使用: as 语法 (TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突)
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```

### 前提

类型断言的使用前提是，值的实际类型(exper)与断言的类型(T)必须满足一个条件。

```ts
expr as T; // expr是T的子类型，或者T是expr的子类型。
```

:::tip
但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为any类型和unknown类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。
:::

### as const

- let命令声明的变量，会被推断为TypeScript中的内置基本类型之一，比如string、number、boolean等。
- const命令声明的变量，会被推断为值类型常量。
- as const断言只能用于字面量，不能用于变量。
- as const也不能用于表达式

```ts
let foo = "hello"; // foo的类型是string
const bar = "hello"; // bar的类型是"hello"
let foo1 = "hello" as const; // foo1的类型是"hello"
foo as const; // ❎ 
let s = ('hello' + 'world') as const; //  ❎ 

const v1 = {
  x: 1,
  y: 2,
}; // 类型是 { x: number; y: number; }

const v2 = {
  x: 1 as const,
  y: 2,
}; // 类型是 { x: 1; y: number; }

const v3 = {
  x: 1,
  y: 2,
} as const; // 类型是 { readonly x: 1; readonly y: 2; }
```

### 非空断言

对于那些可能为空的变量（即可能等于undefined或null），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号!

```ts
let s = "hello";
let len = s!.length;
```

## 13.模块

:::tip
任何包含 import 或 export 语句的文件，就是一个模块（module）。相应地，如果文件不包含 export 语句，就是一个全局的脚本文件。

模块本身就是一个作用域，不属于全局作用域。模块内部的变量、函数、类只在内部可见，对于模块外部是不可见的。暴露给外部的接口，必须用 export 命令声明；如果其他文件要使用模块的接口，必须用 import 命令来输入。

TypeScript 模块除了支持所有 ES 模块的语法，特别之处在于允许输出和输入类型。
:::

### import type

```ts
// foo.ts
export type Foo = {
  foo: string;
};
export const foo = {
  foo: 'foo',
}

import type { Foo } from './foo'; // 只导入类型
// 其他写法
import { type Foo } from './foo';
```

## 14.namespace

:::tip
namespace 是一种将相关代码组织在一起的方式，中文译为“命名空间”。

它出现在 ES 模块诞生之前，作为 TypeScript 自己的模块格式而发明的。但是，自从有了 ES 模块，官方已经不推荐使用 namespace 了。
:::

```ts
namespace Utils {
    function sum(a: number, b: number) {
        return a + b;
    }

    export function sub(a: number, b: number) {
        return a - b;
    }
    sum(1, 2); // 没有export，只能在当前模块使用
}

Utils.sub(1, 2); // 有export，可以在其他模块使用
// import 
import sub = Utils.sub;
sub(1, 2);
```
