
# 第一章

:::tip
TypeScript 官方没有做运行环境，只提供编译器。编译时，会将类型声明和类型相关的代码全部删除，只留下能运行的 JavaScript 代码，并且不会改变 JavaScript 的运行结果。

TypeScript 代码只涉及类型，不涉及值。所有跟“值”相关的处理，都由 JavaScript 完成。

TypeScript 的编译过程，实际上就是把“类型代码”全部拿掉，只保留“值代码”。
:::

## 1.any

### any:（top type）

any 类型主要适用以下两个场合。

- 1.出于特殊原因，需要关闭某些变量的类型检查，就可以把该变量的类型设为 any。
- 2.为了适配以前老的 JavaScript 项目，让代码快速迁移到 TypeScript，可以把变量类型设为 any。有些年代很久的大型 JavaScript 项目，尤其是别人的代码，很难为每一行适配正确的类型，
  这时你为那些类型复杂的变量加上 any，TypeScript 编译时就不会报错。

注意

- any 类型除了关闭类型检查，还有一个很大的问题，就是它会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错。

### unknown：（top type）

为了解决 any 类型“污染”其他变量的问题，TypeScript 3.0 引入了 unknown 类型。它与 any 含义相同，表示类型不确定，可能是任意类型，但是它的使用有一些限制，不像 any 那样自由，可以视为严格版的 any。

怎么才能使用 unknown 类型变量呢？
只有经过“类型缩小”，unknown 类型变量才可以使用。所谓“类型缩小”，就是缩小 unknown 变量的类型范围，确保不会出错。

注意：
1.unknown 类型的变量，不能直接赋值给其他类型的变量（除了 any 类型和 unknown 类型）。 2.不能直接调用 unknown 类型变量的方法和属性。
3.unknown 类型变量能够进行的运算是有限的，只能进行比较运算（运算符==、===、!=、!==、||、&&、?）、取反运算（运算符!）、typeof 运算符和 instanceof 运算符这几种，其他运算都会报错。

### never:（bottom type）

- never 类型的使用场景
1.主要是在一些类型运算之中，保证类型运算的完整性
2.不可能返回值的函数，返回值的类型就可以写成 never
3.如果一个变量可能有多种类型（即联合类型），通常需要使用分支处理每一种类型。这时，处理所有可能的类型之后，剩余的情况就属于 never 类型。

- never 类型的一个重要特点是，可以赋值给任意其他类型。
【TypeScript 就相应规定，任何类型都包含了 never 类型。因此，never 类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。】

## 2.类型系统

### js 类型: (boolean string number undefined null object bigint-ES2020 symbol-ES2015)

- 1.undefined 类型只包含一个值undefined，表示未定义（即还未给出定义，以后可能会有定义）。
- 2.null 类型也只包含一个值null，表示为空（即此处没有值）。
- 3.undefined 和 null 既可以作为值，也可以作为类型，取决于在哪里使用它们。作为值，它们有一个特殊的地方：任何其他类型的变量都可以赋值为undefined或null——目的：跟 JavaScript 的行为保持一致。

注意： 大写类型同时包含包装对象和字面量两种情况，小写类型只包含字面量，不包含包装对象。建议只使用小写类型，不使用大写类型。因为绝大部分使用原始类型的场合，都是使用字面量，不使用包装对象

### ts 类型：（string number boolean array tuple enum any voild null undefied never object union-| intersection-& unknown 值类型）

1. 大写的 Object 类型代表 JavaScript 语言里面的广义对象。所有可以转成对象的值，都是 Object 类型，这囊括了几乎所有的值。
2. 小写的 object 类型代表 JavaScript 里面的狭义对象，即可以用字面量表示的对象，只包含对象、数组和函数，不包括原始类型的值。
    注意，无论是大写的 Object 类型，还是小写的 object 类型，都只包含 JavaScript 内置对象原生的属性和方法，用户自定义的属性和方法都不存在于这两个类型之中
3. TypeScript 规定，单个值也是一种类型，称为“值类型”。TypeScript 推断类型时，遇到 const 命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。
    注意：
    - 3.1 const 命令声明的变量，如果赋值为对象，并不会推断为值类型。
    - 3.2 值类型可能会出现一些很奇怪的报错。const x: 5 = 4 + 1; // 报错（5 是 number 类型的子类型，父类型不能赋值给子类型）
    - 3.3 as(断言) const x: 5 = (4 + 1) as 5; // 正确
4. 联合类型：“类型缩小”是 TypeScript 处理联合类型的标准方法，凡是遇到可能为多种类型的场合，都需要先缩小类型，再进行处理。
5. 交叉类型的主要用途是表示对象的合成。常常用来为对象类型添加新属性。
6. 别名：type 命令用来定义一个类型的别名，别名不允许重名。别名的作用域是块级作用域。别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。 type Age = number;let age: Age = 55;
7. typeof 运算符的移植：js 中运算一个值返回值的类型字符串，ts 中运算一个值返回该值的 TypeScript 类型；typeof 命令的参数不能是类型。

## 3.数组类型

数组（array）和元组（tuple）

### 数组

写法一：

```ts
let arr: number[];
```

写法二：

```ts
let arr: Array<number>;
```

#### 多维数组

```ts
var multi: number[][];
```

#### 只读数组

写法一：

```ts
const arr: readonly number[] = [0, 1];
```

写法二：

```ts
const a1: ReadonlyArray<number> = [0, 1];
const a2: Readonly<number[]> = [0, 1];
```

写法三：

```ts
const arr = [0, 1] as const; //（as const 告诉 TypeScript，推断类型时要把变量 arr 推断为只读数组，从而使得数组成员无法改变。）
```

注意： 1.只读数组是数组的父类型，所以它不能代替数组； 2. readonly 关键字不能与数组的泛型写法一起使用。const arr: readonly `Array<number>` = [0, 1];// 报错

### 元组

TypeScript 【特有】的数据类型，JavaScript 没有单独区分这种类型。
它表示成员类型可以自由设置的数组，即数组的各个成员的类型可以不同。元组【必须】明确声明每个成员的类型。越界的成员会报错。

```ts
const s: [string, string, boolean] = ["a", "b", true];
```

注意：

- 1.使用扩展运算符（...），可以表示不限成员数量的元组。

```ts
type NamedNums = [string, ...number[]];
const a: NamedNums = ["A", 1, 2];
const b: NamedNums = ["B", 1, 2, 3];
```

- 2.如果没有可选成员和扩展运算符，TypeScript 会推断出元组的成员数量（即元组长度）
- 3.如果包含了可选成员，TypeScript 会推断出可能的成员数量。
- 4.扩展运算符（...）将数组（注意，不是元组）转换成一个逗号分隔的序列，这时 TypeScript 会认为这个序列的成员数量是不确定的，因为数组的成员数量是不确定的。
使用扩展运算符传入函数参数，可能发生参数数量与数组长度不匹配的报错。
如何解决：a.就是把成员数量不确定的数组，写成成员数量确定的元组，再使用扩展运算符。b.使用 as const 断言。(这是一个只读的值类型，可以当作数组，也可以当作元组。)

#### 只读元组

写法一：

```ts
type t = readonly [number, string];
```

写法二：

```ts
type t = Readonly<[number, string]>;
```

注意：
只读元组是元组的父类型， 元组可以替代只读元组，而只读元组不能替代元组。如何解决：用 断言 as [number, number]

### 注意： TypeScript 的区分数组和元组的方法：成员类型写在方括号里面的就是元组，写在外面的就是数组

## 4.Symbol 类型

symbol & unique symbol

- symbol: symbol 类型包含所有的 Symbol 值，但是无法表示某一个具体的 Symbol 值。
let x: symbol = Symbol(); // Symbol 值不存在字面量，必须通过变量来引用，不是固定不变的值,所以写不出只包含单个 Symbol 值的那种值类型。
- unique symbol: 为了解决无法表示某一个【具体】的 Symbol 值，TypeScript 设计了 symbol 的一个子类型 unique symbol，它表示单个的、某个具体的 Symbol 值。
const x: unique symbol = Symbol(); 等价于 const x = Symbol();
  注意： 因为 unique symbol 表示单个值，所以这个类型的变量是不能修改值的，只能用 const 命令声明，不能用 let 声明。

### 注意

1. unique symbol 类型是 symbol 类型的子类型
2. unique symbol 类型的一个作用，就是用作属性名，这可以保证不会跟其他属性名冲突。如果要把某一个特定的 Symbol 值当作属性名，那么它的类型只能是 unique symbol，不能是 symbol。
3. unique symbol 类型也可以用作类（class）的属性值，但只能赋值给类的 readonly static 属性。
class C { static readonly foo: unique symbol = Symbol(); }

### 类型推断

1. let 命令声明的变量，推断类型为 symbol。
2. const 命令声明的变量，推断类型为 unique symbol。
3. const 命令声明的变量，如果赋值为另一个 symbol 类型的变量，则推断类型为 symbol。
4. let 命令声明的变量，如果赋值为另一个 unique symbol 类型的变量，则推断类型还是 symbol。

## 5.函数类型

写法一：

```ts
const hello = function(txt: string) => { console.log(txt) } // 推断出变量hello的类型
```

写法二：

```ts
const hello: (txt:string) => void = function(txt) => { console.log(txt) } // 使用箭头函数的形式，为变量hello指定类型
```

写法三：

```ts
let hello: { (txt: string): void };
hello = function (txt) {
  console.log(txt);
}; // 采用对象的写法。{ (参数列表): 返回值 }
```

写法四：

```ts
interface myfn {
  (a: number, b: number): number;
}
let add: myfn = (a, b) => a + b; // 使用 Interface 来声明, 这种写法就是对象写法的翻版
```

注意：

1. 类型里面的参数名（本例是 txt）是必须的，如果写成(string) => void，TypeScript 会理解成函数有一个名叫 string 的参数，并且这个 string 参数的类型是 any。
2. 写法二用起来就很麻烦。因此，往往用 type 命令为函数类型定义一个别名，便于指定给其他变量。type MyFunc = (txt: string) => void;
3. 函数的实际参数个数，可以少于类型指定的参数个数，但是不能多于
4. 如果一个变量要套用另一个函数类型，有一个小技巧，就是使用 typeof 运算符。

```ts
function add(x: number, y: number) {
  return x + y;
}
const myAdd: typeof add = function (x, y) {
  return x * 2 + y;
};
```

5.写法三使用场合：函数本身存在属性的时候，类型就要使用对象的写法。

### Function 类型

TypeScript 提供 Function 类型表示函数，任何函数都属于这个类型。

#### 可选参数

- 参数名带有问号，表示该参数的类型实际上是 原始类型|undefined
- 函数的可选参数只能在参数列表的尾部，跟在必选参数的后面。
- 函数体内部用到可选参数时，需要判断该参数是否为 undefined。
- 可选参数与默认值不能同时使用。

#### 只读参数

```ts
function arraySum(arr: readonly number[]) {
  // 如果函数体内部修改这个数组，就会报错。
  arr[0] = 0; // 报错
}
```

#### 函数 never 类型的应用

1. 抛出错误的函数

```ts
function fail(msg: string): never {
  throw new Error(msg);
}
// 注意，只有抛出错误，才是 never 类型。如果显式用return语句返回一个 Error 对象，返回值就不是 never 类型。
function fail(): Error {
  return new Error("Something failed");
}
```

2.无限执行的函数。

```ts
const sing = function (): never {
  while (true) {
    console.log("sing");
  }
};
```

- never 类型不同于 void 类型。前者表示函数没有执行结束，不可能有返回值；后者表示函数正常执行结束，但是不返回值，或者说返回 undefined。

#### 高阶函数

一个函数的返回值还是一个函数，那么前一个函数就称为高阶函数（higher-order function）。

#### 函数重载

- JavaScript 函数只能有一个实现，必须在这个实现当中，处理不同的参数。
- TypeScript 有些函数可以接受不同类型或不同个数的参数，并且根据参数的不同，会有不同的函数行为。这种根据参数类型不同，执行不同逻辑的行为，称为函数重载（function overload）。

**注意：**

- 函数重载的每个类型声明之间，以及类型声明与函数实现的类型之间，不能有冲突。
- 重载声明的排序很重要，因为 TypeScript 是按照顺序进行检查的，一旦发现符合某个类型声明，就不再往下检查了，所以类型最宽的声明应该放在最后面，防止覆盖其他类型声明。

#### 构造函数

JavaScript 语言使用构造函数，生成对象的实例。构造函数的最大特点，就是必须使用 new 命令调用。

```js
const d = new Date();
```

TypeScript 构造函数的类型写法，就是在参数列表前面加上 new 命令。

```ts
class Animal {
  numLegs: number = 4;
}

type AnimalConstructor = new () => Animal;

function create(c: AnimalConstructor): Animal {
  return new c();
}

const a = create(Animal);
```

```ts
// 构造函数还有另一种类型写法，就是采用对象形式。
type D = {
  new (s: string): object;
};
// F 既可以当作普通函数执行，也可以当作构造函数使用。
type F = {
  new (s: string): object;
  (n?: number): number;
};
```
