# 第五章

## 16.declare 关键字

declare 关键字用来告诉编译器，某个类型是存在的，可以在当前文件中使用。

:::tip
主要作用，就是让当前文件可以使用其他文件声明的类型。举例来说，自己的脚本使用外部库定义的函数，编译器会因为不知道外部函数的类型定义而报错，这时就可以在自己的脚本里面使用declare关键字，告诉编译器外部函数的类型。这样的话，编译单个脚本就不会因为使用了外部类型而报错
:::

declare 关键字可以描述以下类型:

- 变量
- function
- class
- namespace
- Enum
- interface
- type
- module

注意：

- declare 只能用来描述已经存在的变量和数据结构，不能用来声明新的变量和数据结构。另外，所有 declare 语句都不会出现在编译后的文件里面。
- declare 关键字只用来给出类型描述，是纯的类型代码，不允许设置变量的初始值，即不能涉及值。
- declare 关键字后面也不能带有函数的具体实现，只能用来描述函数的类型。
- declare 后面不能给出 Class 的具体实现或初始值

```ts
// 如果要为 JavaScript 引擎的原生对象添加属性和方法，可以使用declare global {}语法。
export {}; // 作用是强制编译器将这个脚本当作模块处理

declare global {
  interface String {
    toSmallString(): string;
  }
}

String.prototype.toSmallString = (): string => {
  // 具体实现
  return "";
};
```

## 17.运算符

### keyof

keyof 是一个单目运算符，接受一个对象类型作为参数，返回该对象的所有键名组成的联合类型。

```ts
type MyObj = {
  foo: number;
  bar: string;
};

type Keys = keyof MyObj; // 'foo'|'bar'
type Keys2 = keyof any; // string|number|symbol 原因：由于 JavaScript 对象的键名只有三种类型
```

- 对于联合类型，keyof 返回成员共有的键名。例如：

```ts
type A = {a: number, b: string};
type B = {b: string, c: boolean};
type C =  keyof (A | B); // 'b'
```

- 对于交叉类型，keyof 返回成员共有的键名。例如：

```ts
type A = {a: number, b: string};
type B = {b: string, c: boolean};
type C =  keyof (A & B);  // 'a'|'b'|'c'
```

用途：

- 1.用于精确表达对象的属性类型。

```ts
function prop(obj: object, key: string): any {
  return obj[key];
}
// 无法表示参数key与参数obj之间的关系;返回值类型只能写成any

// 可以使用keyof来精确表达参数key与参数obj之间的关系
function prop<Obj, K extends keyof Obj>(
  obj:Obj, key:K
):Obj[K] {
  return obj[key];
}
```

- 2.属性映射:将一个类型的所有属性逐一映射成其他值

```ts
type NewProps<Obj> = {
  [Prop in keyof Obj]: boolean;
};

// 用法
type MyObj = { foo: number };

// 等于 { foo: boolean; }
type NewObj = NewProps<MyObj>;
```

### in 运算符

:::tip
JavaScript 语言中，in运算符用来确定对象是否包含某个属性名。

TypeScript 语言的类型运算中，in运算符用来取出（遍历）联合类型的每一个成员类型。
:::

```ts
type U = "a" | "b" | "c";

type Foo = {
  [Prop in U]: number;
};
// 等同于
type Foo = {
  a: number;
  b: number;
  c: number;
};
```

### 方括号运算符

方括号运算符（`[]`）用于取出对象的键值类型，比如`T[K]`会返回对象`T`的属性`K`的类型

```ts
type Person = {
  age: number;
  name: string;
  alive: boolean;
};

// Age 的类型是 number
type Age = Person["age"]; // number

type I1 = Person["age" | "name"]; // string | number
```

### extends...?: 条件运算符

正常使用情况

```ts
// extends用来判断，类型T是否可以赋值给类型U，即T是否为U的子类型
(T extends U ) ? X : Y

// true
type T = 1 extends number ? true : false; // 1 是 number 的子类型
```

联合类型情况的条件运算符

```ts
// 如果A和B都是联合类型，那么条件运算符会展开联合类型，分别进行判断
(A|B) extends U ? X : Y
// 等同于
(A extends U ? X : Y) | (B extends U ? X : Y)

// 如果不希望联合类型被条件运算符展开，可以把extends两侧的操作数都放在方括号里面
// 示例一
type ToArray<Type> = Type extends any ? Type[] : never;

// string[]|number[]
type T = ToArray<string | number>;

// 示例二
type ToArray<Type> = [Type] extends [any] ? Type[] : never;

// (string | number)[]
type T = ToArray<string | number>;
```

### infer 关键字

infer关键字用来定义泛型里面推断出来的类型参数，而不是外部传入的类型参数。infer关键字只能在条件语句中使用，不能在非条件语句中使用

```ts
// 如果参数类型Type是一个数组，那么就将该数组的成员类型推断为Item，即Item是从Type推断出来的。
type Flatten<Type> = Type extends Array<infer Item> ? Item : Type; // infer Item 表示推断数组中的元素类型
// type Flatten<Type, Item> = Type extends Array<Item> ? Item : Type;

let arr: Flatten<number[]> = 1; // arr 的类型是 number
let arr2: Flatten<string> = "1"; // arr2 的类型是 string

// 如果参数类型T是一个函数，那么就将该函数的参数类型推断为A，将函数的返回值类型推断为R；如果T是函数，就返回这个函数的 Promise 版本，否则返回T
type ReturnPromise<T> = T extends (...args: infer A) => infer R
  ? (...args: A) => Promise<R>
  : T;

// 如果T是一个{a：number,b: string}类型，那么就返回一个数组，数组中包含a和b的类型
type MyType<T> = T extends {
  a: infer M;
  b: infer N;
}
  ? [M, N]
  : never;

// 用法示例
type T = MyType<{ a: string; b: number }>;// [string, number]
```

### is 运算符

函数返回布尔值的时候，可以使用is运算符，限定返回值与参数之间的关系。is运算符只能用于返回布尔值的函数中，不能用于其他地方。

```ts
function isString(value: string | number): value is string {
  return typeof value === "string";
}

type Fish = { swim: () => void };
type Bird = { fly: () => void };
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}
```

### 模板字符串

:::tip
TypeScript 允许使用模板字符串，构建类型。模板字符串的最大特点，就是内部可以引用其他类型。
:::

```ts
type World = "world";

// "hello world"
type Greeting = `hello ${World}`;
```

- 模板字符串可以引用的类型一共 6 种，分别是 string、number、bigint、boolean、null、undefined。引用这 6 种以外的类型会报错。

```ts
type Num = 123;
type Obj = { n: 123 };

type T1 = `${Num} received`; // ✅
type T2 = `${Obj} received`; // ❎
```

- 模板字符串里面引用的类型，如果是一个联合类型，那么它返回的也是一个联合类型，即模板字符串可以展开联合类型。

```ts
type T = "A" | "B";

// "A_id"|"B_id"
type U = `${T}_id`;
```

## 18.类型映射

映射（mapping）指的是，将一种类型按照映射规则，转换成另一种类型，通常用于对象类型。

```ts
type A = {
  foo: number;
  bar: number;
};

type B = {
// 属性名索引. in 用来取出右侧的联合类型的每一个成员； keyof A 获取 A 的所有属性名，组成一个联合类型
  [prop in keyof A]: string;
  // [prop in 'foo' | 'bar']: string; // 等同于上面一行
}; // { foo: string; bar: string; }

// 为了增加代码复用性，可以把常用的映射写成泛型
type ToBoolean<T> = {
  [prop in keyof T]: boolean;
};

type D = ToBoolean<A>; // { foo: boolean; bar: boolean; }
```

- TypeScript 的内置工具类型`Partial<T>`的实现，就是使用映射类型。

```ts
type Partial<T> = {
  [P in keyof T]?: T[P]; // ? 表示属性是可选的
};
// 使用
type A = {
  foo: number;
  bar: number;
};

type B = Partial<A>; // { foo?: number; bar?: number; }
```

- TypeScript 内置的工具类型`Readonly<T>`，用来生成只读属性的对象类型。

```ts
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};
// 使用
type A = {
  foo: number;
  bar: number;
};

type B = Readonly<A>; // { readonly foo: number; readonly bar: number; }
```

### 映射修饰符

映射类型允许我们使用`-`和`+`修饰符，表示删除和添加某个属性。

```ts
// 添加可选属性
type Optional<Type> = {
  [Prop in keyof Type]+?: Type[Prop];
};

// 移除可选属性
type Concrete<Type> = {
  [Prop in keyof Type]-?: Type[Prop];
};

// 添加 readonly
type CreateImmutable<Type> = {
  +readonly [Prop in keyof Type]: Type[Prop];
};

// 移除 readonly
type CreateMutable<Type> = {
  -readonly [Prop in keyof Type]: Type[Prop];
};
```

- TypeScript 原生的工具类型`Required<T>`，用来生成将类型T中的所有属性变为必选属性

```ts
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// 使用
type A = {
  foo?: number;
  bar?: number;
};

type B = Required<A>; // { foo: number; bar: number; }
```

### 键名重映射

TypeScript 4.1 引入了键名重映射（key remapping），允许改变键名。

```ts
type A = {
  foo: number;
  bar: number;
};

type B = {
  [p in keyof A as `${p}ID`]: number;
};

// 等同于
type B = {
  fooID: number;
  barID: number;
}；
```

- `as`关键字用于键名重映射，`keyof A`表示A的所有键名，`${p}ID`表示将键名p重映射为pID。
- 应用案例：将对象中的键名从驼峰命名转换为下划线命名。

## 19.类型工具

:::tip
TypeScript 提供了一些内置的类型工具，用来方便地处理各种类型，以及生成新的类型。

TypeScript 内置了 17 个类型工具，可以直接使用。
:::

[Utility Types](https://www.typescriptlang.org/docs/handbook/utility-types.html)

## 20. TypeScript 的注释指令

:::tip
TypeScript 提供了一些注释指令，用来控制编译器的行为。
:::

TypeScript 提供了以下注释指令：

- `@ts-ignore`：忽略下一行代码的 TypeScript 错误。
- `@ts-nocheck`：忽略整个文件或模块的 TypeScript 错误。
- `@ts-check`：启用 TypeScript 错误检查。
- `@ts-expect-error`：标记下一行代码为预期错误。
- `@ts-noemit`：禁用 TypeScript 编译器输出。
- `@ts-noemit-filename`：禁用 TypeScript 编译器输出指定文件。
- `@ts-noemit-module`：禁用 TypeScript 编译器输出指定模块。
- `@ts-noemit-package`：禁用 TypeScript 编译器输出指定包。
- `@ts-noemit-project`：禁用 TypeScript 编译器输出指定项目。

JSDoc

:::tip
jsjoc 是一种用于 JavaScript 的注释规范，它可以帮助开发者在代码中添加注释，以便更好地理解代码的功能和用法。TypeScript 支持使用 JSDoc 注释，以便更好地与 JavaScript 代码集成。
:::

[jsdoc中文文档](https://jsdoc.bootcss.com/index.html)

## 21. 其他

### tsconfig.json

:::tip
tsconfig.json 是 TypeScript 编译器的配置文件，它包含了编译器的各种选项和设置。通过配置 tsconfig.json，可以控制 TypeScript 编译器的行为，例如指定编译的文件、编译的目标版本、编译的输出目录等。

tsconfig.json是 TypeScript 项目的配置文件，放在项目的根目录。反过来说，如果一个目录里面有tsconfig.json，TypeScript 就认为这是项目的根目录。
:::

[tsconfig.json](https://www.typescriptlang.org/tsconfig)

### tsc

:::tip
tsc 是 TypeScript 官方的命令行编译器，用来检查代码，并将其编译成 JavaScript 代码
:::

## 参考链接

- [TypeScript 教程 阮一峰](https://typescript.p6p.net/typescript-tutorial/intro.html)
- [中文网文档](https://typescript.uihtm.com/zh/tutorials/typescript-in-5-minutes.html#google_vignette)

## 反思  :brain:

:::warning
有点沉迷于全盘照搬他人的知识体系，没有自己的思考，导致学习效率低下。如何提炼和总结知识并可以用来解决实际问题，从而形成自己的知识体系，是我在学习过程中需要不断思考和改进的地方。

”见路不走 | 实事求是“
:::

**解决方法**：

- 通过阅读vue源码的过程中来理解ts中的各种语法和特性，并尝试将其应用到实际项目中，以此来加深对ts的理解和掌握。
- 用自己的语言重新解释，让一个外行人听懂
- 在舒适圈的边缘一点点向外拓展
