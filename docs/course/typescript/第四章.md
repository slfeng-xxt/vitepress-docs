# 第四章

## 15.装饰器

:::tip
TypeScript 从早期开始，就支持装饰器。但是，装饰器的语法后来发生了变化。ECMAScript 标准委员会最终通过的语法标准，与 TypeScript 早期使用的语法有很大差异。

目前，TypeScript 5.0 同时支持两种装饰器语法。标准语法可以直接使用，传统语法需要打开--experimentalDecorators编译参数。
:::

### 15.1.标准语法

#### 装饰器的类型结构

```ts
type Decorator = (
  value: DecoratedValue, // 被装饰的值
  context: {
    kind: string; // 装饰器类型.例如，类装饰器、方法装饰器、属性装饰器等,
    name: string | symbol;  // 被装饰的名称,例如，类名、方法名、属性名等
    addInitializer?(initializer: () => void): void; // 添加初始化函数,用于在装饰器执行时调用
    static?: boolean; // 是否为静态装饰器
    private?: boolean; // 是否为私有装饰器
    access: { // 这个属性用于获取被装饰的值的访问信息
      get?(): unknown;
      set?(value: unknown): void;
    };
  }
) => void | ReplacementValue;
```

#### 类装饰器

```ts
function classDecorator(value: ClassDecoratorValue, context: ClassDecoratorContext): void {
 if (context.kind === 'class') {
     value.prototype.name = 'MyClass'; // 给类添加一个属性
 }
}

@classDecorator
class MyClass {}

const myClass = new MyClass();
console.log(myClass.name); // 输出: MyClass
```

#### 属性装饰器

```ts
function logged(value: PropertyDecoratorValue, context: PropertyDecoratorContext): void {
  if (context.kind === 'field') {
    return function (initialValue: any) {
        console.log('MyProperty');
        return initialValue;
    }
  }
}

class MyClass {
  @logged
  name: string;
}

const myClass = new MyClass(); // 输出: MyProperty
```

#### 方法装饰器

```ts
function methodDecorator(value: MethodDecoratorValue, context: MethodDecoratorContext): void {
  if (context.kind === 'method') {
    return function (...args: any[]) {
      console.log('MyMethod');
      return value.apply(this, args);
    }
  }
}

class MyClass {
  @methodDecorator
  myMethod() {
    console.log('Hello, world!');
  }
}

const myClass = new MyClass();
myClass.myMethod(); // 输出: MyMethod Hello, world!
```

#### setter/getter装饰器

```ts
function lazy(value: AccessorDecoratorValue, context: AccessorDecoratorContext): void {
  if (context.kind === 'accessor') {
    return function (initialValue: any) {
      console.log('MyProperty');
      return initialValue;
  }}
}
class MyClass {
  @lazy
  get x() {
    return this.#x;
  }
  set x(value) {
    this.#x = value;
  }
}
```

#### 访问器装饰器

```ts
class C {
  accessor x = 1;
}

// 相当于
class C {
    #x = 1;
    get x() {
        return this.#x;
    }
    set x(value) {
        this.#x = value;
    }
}
```

#### 参数装饰器

```ts
function paramDecorator(value: ParameterDecoratorValue, context: ParameterDecoratorContext): void {
  if (context.kind === 'parameter') {
    return function (target: any, propertyKey: string | symbol, parameterIndex: number) {
      console.log('MyParameter');
    }
  }
}

class MyClass {
  myMethod(@paramDecorator x: number) {
    console.log(x);
  }
}

const myClass = new MyClass();
myClass.myMethod(42); // 输出: MyParameter
```

#### 执行顺序

:::tip
装饰器的执行分为两个阶段。

（1）评估（evaluation）：计算@符号后面的表达式的值，得到的应该是函数。

（2）应用（application）：将评估装饰器后得到的函数，应用于所装饰对象。

:::

Q: 装饰器执行顺序？

- 装饰器的执行顺序是，先评估所有装饰器表达式的值，再将其应用于当前类。
- 应用装饰器时，顺序依次为方法装饰器和属性装饰器，然后是类装饰器

### 15.2.传统语法

:::tip
使用装饰器的旧语法，需要打开--experimentalDecorators编译选项。
:::

```bash
tsc --target ES5 --experimentalDecorators
```

```json
{
  "compilerOptions": {
    "target": "ES6",
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true
  }
}
```

#### 种类

- 类装饰器（Class Decorators）：用于类。
- 属性装饰器（Property Decorators）：用于属性。
- 方法装饰器（Method Decorators）：用于方法。
- 存取器装饰器（Accessor Decorators）：用于类的 set 或 get 方法。
- 参数装饰器（Parameter Decorators）：用于方法的参数。

```ts
@ClassDecorator() // 类装饰器
class A {
  @PropertyDecorator() // 属性装饰器
  name: string;

  @MethodDecorator() // 方法装饰器
  fly(
    @ParameterDecorator() // 参数装饰器
    meters: number
  ) {
    // code
  }

  @AccessorDecorator() //  存取器装饰器
  get egg() {
    // code
  }
  set egg(e) {
    // code
  }
}
```

#### 装饰器执行顺序

- 实例相关的装饰器。
- 静态相关的装饰器。
- 构造方法的参数装饰器。
- 类装饰器。

```ts
function f(key: string): any {
  return function () {
    console.log("执行：", key);
  };
}

@f("类装饰器")
class C {
  @f("静态方法")
  static method() {}

  @f("实例方法")
  method() {}

  constructor(@f("构造方法参数") foo: any) {}
}
const c = new C();
// 执行： 实例方法
// 执行： 静态方法
// 执行： 构造方法参数
// 执行： 类装饰器
```

### 15.3 参考

- [Decorators](https://www.typescriptlang.org/docs/handbook/decorators.html#class-decorators)
- [TypeScript 装饰器全面指南：从基础到高级应用](https://blog.csdn.net/vvilkim/article/details/146715073)
- [TypeScript 5.0](https://zhuanlan.zhihu.com/p/603820333)
